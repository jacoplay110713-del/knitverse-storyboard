<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Knitverse · Hybrid Storyboard v11.0 (Firebase/Admin Mode)</title>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script> 
<script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script> 
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script> 

<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;800&family=Noto+Sans+KR:wght@400;600;800&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{ --bg:#0b0c10; --panel:#10151b; --card:#141c26; --text:#eaf2ff; --muted:#a9b7c6; --blue:#35d0ff; --gold:#ffd54f; --line:#223244; }
  *{box-sizing:border-box}
  body{margin:0;background:radial-gradient(1200px 800px at 80% -10%, #16212c 0%, var(--bg) 55%);color:var(--text);
       font:14px/1.6 'Noto Sans KR', system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
  header{position:sticky;top:0;z-index:20;background:rgba(10,14,20,.85);backdrop-filter:blur(8px);border-bottom:1px solid #162433;
         display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 14px}
  .brand{font-family:'Orbitron';letter-spacing:.14em;color:#35d0ff;font-weight:800;text-transform:uppercase;text-shadow:0 0 10px #35d0ff77}
  .wrap{display:grid;grid-template-columns:400px 1fr;gap:14px;padding:14px}
  @media(max-width:1400px){.wrap{grid-template-columns:1fr}}
  aside{background:var(--panel);border:1px solid #1b2a3a;border-radius:14px;padding:12px;overflow-y:auto;max-height:calc(100vh - 28px - 48px)}
  .section-title{margin:6px 0 8px;font-weight:800;color:#d6e6ff}
  .flow-tools{display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap}
  .flow-list{display:grid;gap:8px}
  .flow{background:linear-gradient(180deg,#0f141b,#0f1822);border:1px solid #203044;border-radius:12px;padding:10px;cursor:grab;position:relative}
  .flow.active{border-color:var(--gold);box-shadow:0 0 0 2px #ffd54f33}
  .flow.drag-over{outline:2px dashed #35d0ff}
  .flow .reord{position:absolute;top:8px;right:8px;font-size:10px;color:#96b}
  /* V6.0: 플로우 목록의 단계 수 표시 제거를 위해 meta 스타일 숨김 */
  .meta{color:#9eb0c6;font-size:12px;line-height:1.4; display: none;} 
  .meta-content{min-height:24px}
  .picker{display:grid;gap:8px;background:#0f141b;border:1px solid #203044;border-radius:12px;padding:10px;margin-top:10px}
  input[type="text"]{width:100%;padding:8px;border-radius:8px;border:1px solid #223244;background:#0b1219;color:#eaf2ff;font-family:'Roboto Mono'}
  .radio{display:flex;gap:12px;align-items:center;margin:6px 0 2px}
  .small{font-size:12px;color:#9fb0c6}

  /* V11.0: 관리자 모드가 아닐 때는 편집 버튼을 숨깁니다. */
  .admin-only { display: none !important; }

  /* 썸네일 영역 */
  .thumbs-section{margin-top:16px; padding-top:16px; border-top:1px solid var(--line);}
  .thumbs{display:grid;grid-template-columns:repeat(auto-fill,minmax(90px,1fr));gap:8px;margin-top:8px}
  .thumb{border:1px solid var(--line);border-radius:10px;padding:6px;background:#0b1219;text-align:center;position:relative;cursor:pointer}
  .thumb.active{border-color:var(--blue);box-shadow:0 0 0 2px #35d0ff33;}
  .thumb[draggable="true"]{cursor:grab}
  .thumb.drag-over{outline:2px dashed #35d0ff}
  .thumb img{max-width:100%;max-height:68px;border-radius:6px;display:block;margin:0 auto 6px}
  .thumb .cap{font-size:11px;color:#cfe2ff}
  .thumb .del{position:absolute;top:6px;right:6px;background:#150e0e;border:1px solid #4a2020;color:#ff9b9b;border-radius:8px;font-size:11px;padding:2px 6px;cursor:pointer;z-index:10}

  main{background:var(--panel);border:1px solid #1b2a3a;border-radius:14px;padding:0;overflow:hidden}
  .toolbar{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:12px;border-bottom:1px solid #192737}
  .crumbs{color:#b9c7d8;font-size:12px}
  .btn{background:#0f141b;border:1px solid #223244;color:#eaf2ff;padding:8px 12px;border-radius:10px;cursor:pointer;flex-shrink:0}
  .btn.primary{border-color:var(--gold);color:#111;background:var(--gold);font-weight:800}
  .btn.danger{border-color:#4a2020;color:#ff9b9b;background:#150e0e;}

  /* V6.0: 이미지 선택 버튼 강조 스타일 */
  .btn.asset-primary{
      background: #ff9800; /* 주황색 배경 */
      border-color: #ffb74d; /* 밝은 주황색 테두리 */
      color: #111; /* 진한 텍스트 */
      font-weight: 800; 
      box-shadow: 0 0 8px #ff980044;
  }

  .stage{padding:14px}
  .unified-stage{display:grid;grid-template-columns:1fr 1fr;gap:14px;} 
  @media(max-width:1400px){.unified-stage{grid-template-columns:1fr}}
  .screen-panel{position:relative;background:linear-gradient(180deg,#0f141b,#101a24);border:1px solid #223244;border-radius:12px;padding:14px;min-height:480px;box-shadow:0 14px 44px #0008;height:100%}
  .stage-wrap{display:grid;grid-template-rows:minmax(480px, auto) 1fr;gap:14px;}

  /* Structure UI */
  .grid{display:grid;grid-template-columns:1fr;gap:10px;margin-top:14px}
  .card{position:relative;background:#182330;border-left:4px solid var(--blue);border-radius:8px;padding:10px 12px;transition:all .1s; cursor:grab;}
  .card.dragging{ opacity: 0.4; } 
  .card.drag-over{ outline: 2px dashed var(--gold); }
  .card:hover{border-left-color:var(--gold);background:#1d2938}
  .card strong{color:var(--blue);font-size:12px;text-transform:uppercase;letter-spacing:.05em;display:block;margin-bottom:2px}
  .card[data-slot*="link"] strong{color:#c7ff35} 
  .card[data-slot*="metric"] strong{color:#ff9933} 
  .meta-content{color:var(--text);font-size:14px;font-weight:600;line-height:1.4;min-height:20px}

  /* HOME (제목) 및 설명 편집 가능 스타일 */
  h2{margin-top:0;font-size:1.6em;border-bottom:1px solid var(--line);padding-bottom:10px;margin-bottom:10px;color:var(--gold);cursor:pointer}
  .struct-desc{color:#d6e6ff;font-size:14px;line-height:1.5;margin-bottom:20px;cursor:pointer}

  .progress{height:8px;background:#0c1219;border:1px solid #1e2b3a;border-radius:999px;overflow:hidden;margin:8px 0 0}
  .bar{height:100%;background:linear-gradient(90deg,#35d0ff,#ffd54f);width:0%}

  iframe{width:100%;height:100%;min-height:540px;border:1px solid #223244;border-radius:12px;background:#0b0c10}
  .imgStageWrap{background:linear-gradient(180deg,#0f141b,#0f1721);border:1px solid #203044;border-radius:12px;padding:10px;height:100%;}
  /* V5.4: Live 이미지 툴바 및 핀 버튼 영역 */
  .imgTools{display:flex;gap:8px;align-items:center;margin-bottom:6px;flex-wrap:wrap;padding: 0 4px;} 
  /* V5.4: 스크롤바 방지 CSS 강화 */
  .imgBoard{position:relative;display:flex;align-items:center;justify-content:center;min-height:540px;background:#0b0c10;border:1px dashed #234;border-radius:12px;
            max-width:100%; max-height:100%; overflow:hidden;} /* overflow:hidden 추가 */
  .imgBoard img{max-width:100%;max-height:100%;width:auto;height:auto;border-radius:8px;display:block;object-fit:contain;}

  .pinLayer{position:absolute;inset:0;pointer-events:none}
  .pin{position:absolute;transform:translate(-50%,-50%);background:#ffd54f;color:#111;border:2px solid #111;border-radius:999px;width:16px;height:16px;display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:800;pointer-events:auto;cursor:pointer}
  .pin:hover{box-shadow:0 0 0 4px #ffd54f33}
  .pinNote{position:absolute;transform:translate(8px,-50%);background:#141c26;color:#eaf2ff;border:1px solid #223244;border-radius:8px;padding:6px;min-width:160px;max-width:260px;font-size:12px}
  .hint{font-size:12px;color:#9fb0c6}

  /* Structure 툴바: 단계 관리 버튼 통합 */
  .structTools{position:relative;display:flex;gap:8px;align-items:center;flex-wrap:wrap;padding-bottom:10px;margin-bottom:10px;border-bottom:1px solid var(--line);}
  .slot-tools{margin-top:10px;padding-top:10px;border-top:1px dashed var(--line);}
</style>
</head>
<body>
<header>
  <div class="brand">KNITVERSE · Hybrid Storyboard V11.0</div>
</header>
<div class="wrap" id="mainWrapper">
  <aside>
    <div class="section-title">플로우 선택 (드래그로 순서 변경)</div>
    <div class="flow-tools">
        <button class="btn admin-only" id="btnAddFlow">플로우 추가</button>
        <button class="btn admin-only" id="btnRenameFlow">이름 변경</button>
        <button class="btn danger admin-only" id="btnDeleteFlow">삭제</button>
    </div>
    <div class="flow-list" id="flowList"></div>

    <div class="section-title" style="margin-top:16px">Live Demo 소스</div>
    <div class="picker admin-only">
      <label>Iframe (HTML) 파일 경로/이름 입력</label>
      <div id="srcIframeBox">
        <input id="srcText" type="text" placeholder="예: knitverse_mvp_skin_pro.html 또는 ./sub/app.html">
        <button class="btn" id="applySrc">적용</button>
        <div class="small">또는 파일 선택 →</div>
        <input id="srcFile" type="file" accept=".html,.htm">
        <div class="small" id="srcStatus">현재: 연결되지 않음</div>
      </div>
    </div>

    <div class="thumbs-section admin-only">
        <div class="section-title">단계별 이미지 삽입 (Step Images)</div>
        <div class="small">이미지를 여기에 업로드하면 자동으로 이미지 모드로 전환됩니다.</div>
        <div class="imgTools" style="padding: 10px 0;">
            <button class="btn asset-primary" id="btnPickImages">이미지 선택</button>
            <button class="btn" id="btnAssignFromCurrent">현재 단계부터 재할당</button>
            <button class="btn danger" id="btnClearMap">이 플로우 매핑 초기화</button>
            <input id="imgFiles" type="file" accept="image/*" multiple style="display:none">
            <div class="small" id="imgInfo" style="flex-basis: 100%;"></div>
        </div>

        <div class="thumbs" id="imgList"></div>
        <div class="small">드래그앤드롭으로 이미지 순서 변경 가능. 썸네일 클릭 시 해당 단계로 이동.</div>
    </div>

    <div class="thumbs-section">
        <div class="section-title">작업 저장 / 불러오기 (JSON)</div>
        <label class="small admin-only" style="margin-top: 8px;">저장할 파일명 (확장자 제외)</label>
        <input id="saveFileName" type="text" placeholder="예: knitverse_project_final" style="margin-bottom: 8px;">

        <button class="btn primary" id="btnExportWork">작업 저장 (JSON)</button> 

        <div style="height: 10px;"></div>
        <button class="btn admin-only" id="btnImportWork">작업 불러오기 (파일 선택)</button>
        <input id="workFile" type="file" accept=".json" style="display:none">
        <div class="small">저장된 JSON 파일을 불러와 작업 환경을 복원합니다.</div>
    </div>

  </aside>
  <main id="mainContent">
    <div class="toolbar">
      <div class="crumbs" id="crumbs">HOME</div>
      <div class="controls">
        <button class="btn" id="btnExportImage">화면 캡처 (PNG)</button> 
        <button class="btn" id="btnPrev">← 이전</button>
        <button class="btn primary" id="btnNext">다음 →</button>
      </div>
    </div>

    <div class="stage unified-stage">

      <div id="structPanel" class="screen-panel">
        <div class="structTools">
          <button class="btn admin-only" id="btnStepAdd">단계 추가</button>
          <button class="btn admin-only" id="btnStepClone">현재 단계 복제</button>
          <button class="btn admin-only" id="btnStepRename">이름 변경</button>
          <button class="btn danger admin-only" id="btnStepDelete">단계 삭제</button>
          <div style="flex-basis:100%; height:8px;"></div>
          <label class="small admin-only"><input type="checkbox" id="structPinMode"> 핀 추가</label> 
          <button class="btn admin-only" id="btnStructClearPins">핀 삭제</button>
        </div>
        <div id="structBody"></div>
        <div class="pinLayer" id="structPinLayer"></div>
      </div>

      <div class="stage-wrap">
        <div id="iframePane" class="imgStageWrap" style="display:none">
          <div class="imgTools admin-only">
            <span class="hint">Live Demo (Iframe) 영역입니다. (Step Images가 우선입니다.)</span>
          </div>
          <iframe id="liveFrame"></iframe>
          <div class="hint">해시 내비(#home/#shop/#classes/#mypage)로 스텝 이동에 맞춰 연동합니다.</div>
        </div>
        <div id="imagesPane" class="imgStageWrap" style="display:none">
          <div class="imgTools admin-only">
            <label><input type="checkbox" id="pinMode"> 핀 추가</label>
            <button class="btn" id="btnClearPins">핀 삭제</button>
            <span class="hint">이미지 위를 클릭하면 핀과 설명을 추가할 수 있어요.</span>
          </div>
          <div class="imgBoard" id="imgBoard">
            <img id="stepImg" alt="Step image">
            <div class="pinLayer" id="pinLayer"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="progress" style="margin-top:14px"><div class="bar" id="bar"></div></div>
    <footer id="footer"></footer>
  </main>
</div>

<div id="loadingOverlay" style="position:fixed; inset:0; background:rgba(0,0,0,.8); z-index:9999; display:none; flex-direction:column; justify-content:center; align-items:center; color:white; font-size:16px;">
    <div style="width:300px; padding:20px; background:#141c26; border-radius:12px; border:1px solid #35d0ff;">
        <div style="font-weight:bold; margin-bottom:10px;" id="loadingTitle">작업 데이터 저장 준비 중...</div>
        <div id="progressBarContainer" style="height:10px; background:#0b0c10; border-radius:5px; overflow:hidden;">
            <div id="progressBar" style="height:100%; width:0; background:#ffd54f;"></div>
        </div>
        <div id="progressText" style="margin-top:10px; text-align:right;">0%</div>
    </div>
</div>

<script>
    // 1. Firebase 설정 정보 (사용자님의 고유 키가 포함됨)
    const firebaseConfig = {
        apiKey: "AIzaSyBcPS6qESHwa9Y9RMKfocKesffILk_FIT8",
        authDomain: "knitverse-storyboard-project.firebaseapp.com",
        projectId: "knitverse-storyboard-project",
        storageBucket: "knitverse-storyboard-project.firebasestorage.app",
        messagingSenderId: "411428209337",
        appId: "1:411428209337:web:1c6c0df694bf12c4851168",
        measurementId: "G-B66MGKHE8S"
    };

    // 2. Firebase 앱 초기화 및 Firestore 인스턴스 생성
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    // Firestore에 저장할 문서 ID (모든 스토리보드 데이터는 이 하나의 문서에 저장됨)
    const STORYBOARD_DOC_ID = 'knitverse-main-data';
</script>


<script>
/* =========================
   V11.0: 관리자 모드 로직 추가
========================= */
let isAdminMode = false;
// V11.0: 관리자 모드 확인 및 비밀번호 설정
function checkAdminMode() {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('admin') === 'true') {
        // 비밀번호 설정: 'knitverse2025' 대신 원하는 비밀번호를 설정하세요.
        const password = prompt("관리자 모드 접속을 위해 비밀번호를 입력해주세요."); 
        if (password === 'knitverse2025') { 
            isAdminMode = true;
            // 모든 .admin-only 클래스의 display: none을 해제합니다.
            document.querySelectorAll('.admin-only').forEach(el => {
                const tagName = el.tagName.toLowerCase();
                if (['button', 'input', 'label'].includes(tagName)) {
                    el.style.display = 'inline-block';
                } else if (['div', 'section'].includes(tagName) || el.classList.contains('flow-tools') || el.classList.contains('imgTools') || el.classList.contains('structTools')) {
                    el.style.display = 'flex';
                } else {
                    el.style.display = 'block';
                }
            });
            console.log("관리자 모드가 활성화되었습니다.");
        } else {
            alert("비밀번호가 틀렸습니다. 읽기 전용 모드로 전환됩니다.");
            // 보안을 위해 URL에서 admin=true 매개변수를 제거합니다.
            const newUrl = window.location.href.split('?')[0];
            history.replaceState(null, '', newUrl);
        }
    }
}


/* =========================
   플로우 정의 (5개) 
========================= */
const BASE_FLOWS=[
 {key:'fan',     title:'팬 · 구매 플로우', map:['home','shop','product','checkout','done'], 
  steps:[
   {title:'HOME',body:'히어로 배너에서 상품 진입', slots:[{key:'core', name:'핵심 요소', content:'CTA · 사용자 목표 · 성공 시그널'},{key:'link', name:'연결', content:'쇼핑 리스트로 이동'},{key:'metric', name:'메트릭', content:'Home to Shop 클릭률'}]},
   {title:'SHOP',body:'트렌딩 상품 리스트', slots:[{key:'core', name:'상품 리스트 핵심', content:'상품 리스트 핵심'},{key:'link', name:'상품 상세로 이동', content:'상품 상세로 이동'},{key:'metric', name:'상품 조회율', content:'상품 조회율'}]},
   {title:'상세',body:'상품 상세 페이지', slots:[{key:'core', name:'상품 상세 핵심', content:'상품 상세 핵심'},{key:'link', name:'체크아웃으로 이동', content:'체크아웃으로 이동'},{key:'metric', name:'장바구니 담기율', content:'장바구니 담기율'}]},
   {title:'체크아웃',body:'결제 요약 화면', slots:[{key:'core', name:'결제 핵심', content:'결제 핵심'},{key:'link', name:'주문 완료', content:'주문 완료'},{key:'metric', name:'결제 성공률', content:'결제 성공률'}]},
   {title:'완료',body:'주문 완료', slots:[{key:'core', name:'완료 핵심', content:'완료 핵심'},{key:'link', name:'마이페이지로 이동', content:'마이페이지로 이동'},{key:'metric', name:'재방문 유도', content:'재방문 유도'}]}
  ]},
 {key:'rookie',  title:'루키 · 성장 플로우', map:['home','apply','klgc','upload','publish'], steps:[{title:'HOME',body:'APPLY 클릭'},{title:'Apply Form',body:'아티스트 지원 폼'},{title:'K-LGC',body:'4주 커리큘럼 단계'},{title:'Upload',body:'상품 업로드'},{title:'Publish',body:'상품 공개 완료'}]},
 {key:'learner', title:'학습자 · 클래스 플로우', map:['home','classes','detail','enroll','play'], steps:[{title:'HOME',body:'클래스 탭 클릭'},{title:'Class List',body:'강의 목록'},{title:'Detail',body:'강의 상세 설명'},{key:'enroll', name:'수강 등록', content:'수강 등록'},{key:'player', name:'강의 재생', content:'강의 재생'}]},
 {key:'creator', title:'액티브/마스터 작가 플로우', map:['home','classes','create','sell','legacy'], steps:[{title:'HOME',body:'MY PAGE에서 크리에이터 허브 진입'},{title:'클래스 개설',body:'커리큘럼/가격/언어 설정'},{title:'상품화',body:'키트/도안 번들 구성 · 재고'},{title:'판매/프로모션',body:'런칭 · 팬/커뮤니티 프로모션'},{title:'레거시 축적',body:'멘토링/평가 · 레거시 스코어 상승'}]},
 {key:'support', title:'서포터즈 플로우', map:['home','community','apply','board','credit'], steps:[{title:'HOME',body:'COMMUNITY 진입'},{title:'Supporter Hub',body:'역할 선택/가용성 설정'},{title:'Apply',body:'프로필 제출'},{title:'Matching Board',body:'프로젝트 매칭/승인'},{title:'크레딧 & 보상',content:'K-Points 적립/정산'}]}
];
/* =========================
   상태 & 저장 키 + 헬퍼 (V5.0 키 유지)
========================= */
let flows = [];
let currentFlowIdx = 0;
let currentStep = 0;

const STORAGE = {
  ORDER: 'kv_v50_flow_order', 
  SRC:   'kv_v50_src',
  MODE:  'kv_v50_mode',
  IMGS:  'kv_v50_images',
  PINS:  'kv_v50_pins',
  SPINS: 'kv_v50_struct_pins', 
  FLOWS: 'kv_v50_flows',   
  STATE: 'kv_v50_state', // (로컬 저장소 유지)
  // V6.1: 모든 저장 키 리스트 (Export 용도)
  ALL_KEYS: ['kv_v50_flow_order', 'kv_v50_src', 'kv_v50_mode', 'kv_v50_images', 'kv_v50_pins', 'kv_v50_struct_pins', 'kv_v50_flows', 'kv_v50_state']
};

// V8.0: Base64 <-> Blob URL 변환 시 캐싱을 위한 전역 맵
const BLOB_URL_CACHE = {}; 
const LZ = window.LZString;

// V10.0: LocalStorage 대신 Firebase를 사용하도록 모든 저장/불러오기 함수 교체

/* =========================
   V10.0: Firebase 데이터 저장/불러오기 헬퍼 (LocalStorage 대체)
========================= */

// Firestore에서 데이터 불러오기 (비동기 처리 필요)
async function getDB(key) {
    try {
        const doc = await db.collection("storyboard").doc(STORYBOARD_DOC_ID).get();
        if (doc.exists) {
            const data = doc.data();
            // 특정 키(FLOWS, IMGS 등)에 해당하는 값만 반환
            return data[key] || null; 
        }
        return null;
    } catch (e) {
        console.error("Firebase read error:", e);
        return null;
    }
}

// Firestore에 데이터 저장하기 (비동기 처리 필요)
async function setDB(key, val) {
    // V11.0: 관리자 모드가 아닐 경우 쓰기를 막습니다.
    if (!isAdminMode) {
        console.warn("읽기 전용 모드에서는 DB 저장을 시도할 수 없습니다.");
        return false;
    }

    try {
        // FLOWS, IMGS 등의 객체/배열 형태로 저장
        await db.collection("storyboard").doc(STORYBOARD_DOC_ID).set({
            [key]: val
        }, { merge: true }); // 기존 데이터는 유지하고 해당 키만 업데이트

        return true;
    } catch (e) {
        console.error("Firebase write error:", e);
        return false;
    }
}

// V10.0: UUID 함수 유지
function uuid(){ return Math.random().toString(36).slice(2,10); } 

// V10.0: 로컬 상태 저장/복원 함수는 기존 로직을 유지 (STATE만 사용)
function getLS(key, def){ try{ return JSON.parse(localStorage.getItem(key) || JSON.stringify(def)); } catch(e){ return def; } }
function setLS(key, val){ localStorage.setItem(key, JSON.stringify(val)); }

// V10.0: DB 저장/로드 함수 재정의 (기존 setLS/getLS 호출 대체)
async function loadFlowsFromDB(){ return await getDB(STORAGE.FLOWS); }
async function saveFlowsToDB(flowsArr){ return await setDB(STORAGE.FLOWS, flowsArr); }

async function getImagesFromDB(){ return await getDB(STORAGE.IMGS); }
async function setImagesToDB(data){ return await setDB(STORAGE.IMGS, data); }

async function getPinsFromDB(){ return await getDB(STORAGE.PINS); }
async function setPinsToDB(data){ return await setDB(STORAGE.PINS, data); }

async function getStructPinsFromDB(){ return await getDB(STORAGE.SPINS); }
async function setStructPinsToDB(data){ return await setDB(STORAGE.SPINS, data); }

async function getSrcFromDB(){ return await getDB(STORAGE.SRC); }
async function setSrcToDB(v){ return await setDB(STORAGE.SRC, v); }


/* =========================
   Base64 <-> Blob/URL + LZ-String 헬퍼 
========================= */

// V8.0: 압축 헬퍼
function compressData(base64) {
    if (!base64 || !base64.startsWith('data:')) return base64;
    try {
        return 'LZ+' + LZ.compressToUTF16(base64); 
    } catch(e) {
        console.error("Compression failed:", e);
        return base64;
    }
}

// V8.0: 압축 해제 헬퍼
function decompressData(data) {
    if (!data || !data.startsWith('LZ+')) return data;
    try {
        const compressed = data.substring(3);
        const decompressed = LZ.decompressFromUTF16(compressed);
        return decompressed || data; 
    } catch(e) {
        console.error("Decompression failed:", e);
        return data; 
    }
}


// V7.0: Blob URL을 Base64 문자열로 변환 (비동기)
function urlToBase64(url) {
    return new Promise((resolve, reject) => {
        if (!url || !url.startsWith('blob:')) {
            resolve({url: url, base64: url});
            return;
        }

        fetch(url)
            .then(response => {
                if (!response.ok) throw new Error(`Fetch failed for Blob URL: ${url}`);
                return response.blob();
            })
            .then(blob => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    const rawBase64 = reader.result;
                    const compressedBase64 = compressData(rawBase64); 
                    resolve({url: url, base64: compressedBase64});
                };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            })
            .catch(error => {
                console.warn(`[Export Warning] Failed to convert Blob URL to Base64: ${url}`, error);
                resolve({url: url, base64: url, error: true}); 
            });
    });
}

// V8.0: Base64 문자열을 Blob URL로 복원 (LZ-String 해제 및 디코딩 안정성 강화)
function base64ToUrl(compressedBase64) {
    if (!compressedBase64 || !(compressedBase64.startsWith('data:') || compressedBase64.startsWith('LZ+'))) {
        return compressedBase64;
    }

    if (BLOB_URL_CACHE[compressedBase64]) {
        return BLOB_URL_CACHE[compressedBase64];
    }

    const base64 = decompressData(compressedBase64);

    if (!base64 || !base64.startsWith('data:')) {
        console.error("Error: Decompressed data is not a valid Base64 string.");
        return ''; 
    }

    try {
        const parts = base64.split(';base64,');
        if (parts.length !== 2) {
            console.error("Invalid Base64 format during decoding.");
            return '';
        }

        const contentTypeMatch = parts[0].match(/:(.*?)$/);
        const contentType = contentTypeMatch ? contentTypeMatch[1] : 'image/png'; 

        const raw = window.atob(parts[1]);
        const rawLength = raw.length;
        const uInt8Array = new Uint8Array(new ArrayBuffer(rawLength)); 

        for (let i = 0; i < rawLength; ++i) {
            uInt8Array[i] = raw.charCodeAt(i);
        }
        const blob = new Blob([uInt8Array], { type: contentType });
        const url = URL.createObjectURL(blob);

        BLOB_URL_CACHE[compressedBase64] = url;
        return url;

    } catch (e) {
        console.error("Error decoding Base64 to Blob, returning empty string:", e);
        return '';
    }
}

// V10.0: 초기화 시점에 DB에서 이미지 데이터를 불러와 Blob URL로 변환 (Base64 원본은 DB에 유지)
async function restoreImagesFromDB() {
    // V10.0: 이미지 데이터를 DB에서 불러옴
    const imgsData = await getImagesFromDB() || {}; 
    let hasRestored = false;
    const urlMap = {}; 

    for (const flowKey in imgsData) {
        const flowData = imgsData[flowKey];
        if (flowData) {
            // Gallery URL 복원 (Base64 -> Blob URL)
            if (flowData.gallery && Array.isArray(flowData.gallery)) {
                flowData.gallery = flowData.gallery.map(compressedBase64 => {
                    if (compressedBase64 && (compressedBase64.startsWith('data:') || compressedBase64.startsWith('LZ+'))) {
                        if (!urlMap[compressedBase64]) {
                            urlMap[compressedBase64] = base64ToUrl(compressedBase64);
                        }
                        hasRestored = true;
                        return urlMap[compressedBase64];
                    }
                    return compressedBase64;
                });
            }

            // StepMap URL 복원 (Base64 -> Blob URL)
            if (flowData.stepMap) {
                for (const step in flowData.stepMap) {
                    const compressedBase64 = flowData.stepMap[step];
                    if (compressedBase64 && (compressedBase64.startsWith('data:') || compressedBase64.startsWith('LZ+'))) {
                        if (!urlMap[compressedBase64]) {
                            urlMap[compressedBase64] = base64ToUrl(compressedBase64);
                        }
                        flowData.stepMap[step] = urlMap[compressedBase64];
                        hasRestored = true;
                    }
                }
            }
        }
    }

    if (hasRestored) {
        // V10.0: 복원된 Blob URL을 다시 로컬 스토리지에 임시 저장 (휘발성 데이터)
        setLS(STORAGE.IMGS, imgsData);
    }

    return imgsData;
}


/* =========================
   초기화 (플로우 순서 복원 & 병합) - V10.0 Firebase 연동
========================= */
async function initFlows(){ 
  // 1. FLOWS 데이터를 Firebase에서 불러오기
  const saved = await loadFlowsFromDB(); 

  if(saved && Array.isArray(saved) && saved.length){
    flows = saved;
    // V5.5: 저장된 플로우 데이터에 슬롯이 없으면 기본 슬롯 추가 (기존 호환성 로직 유지)
    flows.forEach(f => {
        f.steps.forEach(s => {
            if(!s.slots){
                 s.slots = [
                    {key:'core', name:'핵심 요소', content: s.core || '핵심 요소'},
                    {key:'link', name:'연결', content: '다음 화면으로 넘어가는 트리거'},
                    {key:'metric', name:'메트릭', content: '전환/이탈 포인트, GA 이벤트'}
                ];
            }
            if(!s.body) s.body = '설명 없음';
        });
    });
  }else{
    // Firebase에 데이터가 없을 경우 기본값으로 초기화
    const processedBaseFlows = BASE_FLOWS.map(f => ({
        ...f,
        steps: f.steps.slice(0, 5),
        map: f.map.slice(0, 5)
    }));

    const processedByKey = Object.fromEntries(processedBaseFlows.map(f=>[f.key, f]));
    const order = getLS(STORAGE.ORDER, BASE_FLOWS.map(f=>f.key)); 
    flows = order.map(k => processedByKey[k] || processedBaseFlows.find(f=>f.key === k) || null).filter(Boolean);
    processedBaseFlows.forEach(f=>{ if(!flows.find(x=>x.key===f.key)) flows.push(f); });

    // 초기 기본값을 Firebase에 저장 (최초 1회 실행)
    if (isAdminMode) { // V11.0: 관리자 모드에서만 초기 데이터 쓰기 허용
        await saveFlowsToDB(flows);
    }
  }

  // 2. 이미지 데이터 로드 및 복원
  await restoreImagesFromDB();

  // 3. SRC, PINS, SPINS 데이터도 DB에서 불러와 로컬 스토리지에 복원
  const src = await getSrcFromDB();
  if (src) setLS(STORAGE.SRC, src);

  const pins = await getPinsFromDB();
  if (pins) setLS(STORAGE.PINS, pins);

  const structPins = await getStructPinsFromDB();
  if (structPins) setLS(STORAGE.SPINS, structPins);
}

/* =========================
   세션 상태 저장/복원
========================= */
// V10.0: 현재 인덱스(STATE)만 로컬 스토리지 사용
function saveState(){
  setLS(STORAGE.STATE, { flowIdx: currentFlowIdx, stepIdx: currentStep });
}
function loadState(){
  const s = getLS(STORAGE.STATE, null);
  if(!s) return;
  currentFlowIdx = Math.min(Math.max(0, s.flowIdx||0), flows.length-1);
  currentStep    = Math.min(Math.max(0, s.stepIdx||0), flowLen()-1);
}

/* =========================
   Structure: 핀/메모 + 카드 데이터
========================= */
// V10.0: 핀 데이터는 DB에서 불러온 후 로컬 스토리지에 캐시된 데이터를 사용
async function structPins(flowKey=activeFlow().key, step=currentStep){
  const o = getLS(STORAGE.SPINS, {}); 
  // V10.0: DB 연동 후 로컬 스토리지에 캐시된 데이터 사용
  if(!o[flowKey]) o[flowKey]={};
  if(!o[flowKey][step]) o[flowKey][step]=[];
  return o[flowKey][step];
}
async function setStructPins(list, flowKey=activeFlow().key, step=currentStep){
  const o = getLS(STORAGE.SPINS, {});
  if(!o[flowKey]) o[flowKey]={};
  o[flowKey][step]=list;
  setLS(STORAGE.SPINS, o); 
  await setStructPinsToDB(o); // ✨ DB에 영구 저장
  saveState();
}

// Structure 카드 데이터 렌더링 (로직 유지)
function renderStructure(){
  const f=activeFlow(), s=activeStepData();

  const flowStepsSummary = f.steps.map(step => step.title).join(' - ');

  let slotsHtml = '';
  if(s.slots && Array.isArray(s.slots)){
    slotsHtml = s.slots.map((slot, index) => `
      <div class="card" data-key="${slot.key}" data-slot-name="${slot.name}" draggable="true" data-index="${index}">
        <strong>${slot.name} (${slot.key.toUpperCase().split('_')[0]})</strong>
        <div class="meta-content">${slot.content || ''}</div>
      </div>
    `).join('');
  }

  $('structBody').innerHTML = `
    <h2 id="stepTitle" class="editable-title admin-only">${s.title}</h2>
    <p id="stepBody" class="struct-desc editable-body admin-only">${s.body||'설명 없음'}</p>
    <div class="grid">${slotsHtml}</div>
    <div class="slot-tools">
        <button class="btn admin-only" id="btnAddSlot">슬롯 추가</button>
        <button class="btn danger admin-only" id="btnDeleteSlot">슬롯 삭제</button>
    </div>
    `;

  $('crumbs').innerText = f.title + ' › ' + flowStepsSummary; 
  $('bar').style.width = ((currentStep+1)/flowLen()*100)+'%';
  $('footer').innerText = `${f.title} · Step ${currentStep+1}/${flowLen()}`;
  $('btnPrev').disabled = currentStep===0;
  $('btnNext').disabled = currentStep===flowLen()-1;

  renderStructPinLayer();
  attachEditListeners();
}

// 편집 리스너 부착 (로직 유지)
function attachEditListeners(){
    const s = activeStepData();

    // 1. 단계 제목 편집
    $('stepTitle').addEventListener('dblclick', async (e) => { // async 추가
        if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
        const newTitle = prompt('단계 이름 변경:', s.title);
        if (newTitle !== null && newTitle.trim() !== '') {
            s.title = newTitle.trim();
            await saveFlowsToDB(flows); // ✨ DB에 저장
            renderAll();
        }
    });

    // 2. 단계 설명 편집
    $('stepBody').addEventListener('dblclick', async (e) => { // async 추가
        if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
        const newBody = prompt('단계 설명 변경:', s.body);
        if (newBody !== null) {
            s.body = newBody.trim() || '설명 없음';
            await saveFlowsToDB(flows); // ✨ DB에 저장
            renderStructure();
        }
    });

    // 3. 슬롯 콘텐츠 편집
    document.querySelectorAll('#structBody .card').forEach(card => {
        card.addEventListener('dblclick', async (e) => { // async 추가
            if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
            if(card.classList.contains('dragging')) return; 

            const key = card.dataset.key;
            const slot = s.slots.find(sl => sl.key === key);

            const newContent = prompt(`'${slot.name}' 내용 수정:`, slot.content || '');

            if (newContent !== null) {
                slot.content = newContent.trim();
                await saveFlowsToDB(flows); // ✨ DB에 저장
                renderStructure();
            }
        });
    });

    // 4. 슬롯 추가 버튼
    $('btnAddSlot').addEventListener('click', async () => { // async 추가
        if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
        const name = prompt('새 슬롯의 이름(제목)을 입력하세요:').trim();
        if (!name) return;
        const key = name.toLowerCase().replace(/[^a-z0-9]/g, '_').slice(0, 10) + uuid().slice(0,4);

        s.slots.push({ key: key, name: name, content: '' });
        await saveFlowsToDB(flows); // ✨ DB에 저장
        renderStructure();
    });

    // 5. 슬롯 삭제 버튼
    $('btnDeleteSlot').addEventListener('click', async () => { // async 추가
        if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
        if (!s.slots || s.slots.length === 0) { alert('삭제할 슬롯이 없습니다.'); return; }

        const slotNames = s.slots.map((sl, idx) => `${idx + 1}. ${sl.name}`).join('\n');
        const indexStr = prompt(`삭제할 슬롯의 번호(1~${s.slots.length})를 입력하세요:\n\n${slotNames}`);
        const index = parseInt(indexStr, 10) - 1;

        if (index >= 0 && index < s.slots.length) {
            if(confirm(`"${s.slots[index].name}" 슬롯을 삭제하시겠습니까?`)){
                s.slots.splice(index, 1);
                await saveFlowsToDB(flows); // ✨ DB에 저장
                renderStructure();
            }
        } else if(indexStr !== null && indexStr.trim() !== ''){
            alert('유효하지 않은 번호입니다.');
        }
    });

    // 6. 슬롯 드래그앤드롭 (순서 변경)
    document.querySelectorAll('#structBody .card').forEach(card => {
        card.addEventListener('drop', async (e) => { // async 추가
            if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가

            const fromIndex = parseInt(e.dataTransfer.getData('text/plain'), 10);
            const toIndex = parseInt(card.dataset.index, 10);

            if (fromIndex !== toIndex) {
                const [movedItem] = s.slots.splice(fromIndex, 1);
                s.slots.splice(toIndex, 0, movedItem);

                await saveFlowsToDB(flows); // ✨ DB에 저장
                renderStructure(); 
            }
        });
    });
}


let structPinMode=false;
$('structPinMode').addEventListener('change', e=>{ structPinMode = e.target.checked; });
$('btnStructClearPins').addEventListener('click', async ()=>{ 
    if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
    await setStructPins([]); renderStructPinLayer(); 
}); // async 추가

function renderStructPinLayer(){
  const layer = $('structPinLayer'); layer.innerHTML='';
  const list = structPins(); // 동기적으로 로컬 캐시 사용
  list.forEach((p,idx)=>{
    const pin = document.createElement('div');
    pin.className='pin'; pin.innerText=String(idx+1);
    pin.style.left=p.x+'%'; pin.style.top=p.y+'%';
    const note=document.createElement('div');
    note.className='pinNote'; note.textContent=p.text||'(메모 없음)'; note.style.display='none';
    pin.addEventListener('mouseenter', ()=>{ note.style.display='block'; });
    pin.addEventListener('mouseleave', ()=>{ note.style.display='none'; });
    pin.addEventListener('click', async (ev)=>{ // async 추가
      if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
      ev.stopPropagation();
      const v = prompt('핀 수정 (비우면 삭제)', p.text||'');
      if(v===null) return;
      const arr=list.slice();
      if(v.trim()===''){ await setStructPins(arr.filter(x=>x.id!==p.id)); } // ✨ DB에 저장
      else { p.text=v.trim(); await setStructPins(arr); } // ✨ DB에 저장
      renderStructPinLayer();
    });
    const wrap=document.createElement('div');
    wrap.style.position='absolute'; wrap.style.left=p.x+'%'; wrap.style.top=p.y+'%'; wrap.style.transform='translate(-50%,-50%)';
    wrap.appendChild(pin); wrap.appendChild(note);
    layer.appendChild(wrap);
  });
}
$('structPanel').addEventListener('click', async (e)=>{ // async 추가
  if(!structPinMode || !isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
  if(e.target.closest('.structTools') || e.target.closest('.card') || e.target.closest('#stepTitle') || e.target.closest('#stepBody') || e.target.closest('.slot-tools')) return; 

  const rect = $('structPanel').getBoundingClientRect();
  const x = ((e.clientX-rect.left)/rect.width)*100;
  const y = ((e.clientY-rect.top)/rect.height)*100;
  const text = prompt('메모 내용을 입력하세요:');
  if(text===null) return;
  const list = structPins();
  list.push({id:uuid(), x:+x.toFixed(2), y:+y.toFixed(2), text:text.trim()});
  await setStructPins(list); renderStructPinLayer(); // ✨ DB에 저장

  structPinMode = false;
  $('structPinMode').checked = false;
});
/* Live: Iframe + Images */
// V10.0: getSrc는 로컬 스토리지에 캐시된 데이터를 사용
function getSrc(){ 
  const src = getLS(STORAGE.SRC, '') || '';
  if(!src) return '';
  // V10.0: 임시 Blob URL이 남아있다면 Base64 원본으로 대체 (Export/Import 시 Base64가 아니면 의미 없음)
  if (src.startsWith('blob:')) return ''; 
  return src;
}
$('applySrc').onclick=async ()=>{ // async 추가
  if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
  const v=$('srcText').value.trim(); 
  if(v){ 
    await setSrcToDB(v); // ✨ DB에 저장
    setLS(STORAGE.SRC, v);
  }
  updateLiveMode(localStorage.getItem(STORAGE.MODE)); 
}; 
$('srcFile').addEventListener('change', async e=>{ // async 추가
  if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
  const f=e.target.files[0]; 
  if(!f) return; 
  const url = URL.createObjectURL(f);
  await setSrcToDB(url); // ✨ DB에 임시 저장 (휘발성)
  setLS(STORAGE.SRC, url);
  updateLiveMode('iframe'); 
}); 

function liveHashForStep(flowKey, stepIdx){
  const f=flows.find(x=>x.key===flowKey); const key=f.map[stepIdx];
  const map={ home:'#home', shop:'#shop', product:'#shop', checkout:'#shop', done:'#mypage',
              apply:'#home', klgc:'#classes', upload:'#shop', publish:'#shop',
              classes:'#classes', detail:'#classes', enroll:'#classes', play:'#classes',
              create:'#classes', sell:'#shop', legacy:'#mypage',
              community:'#community', board:'#community', credit:'#mypage', next:'#home' };
  return map[key] || '#home';
}
function navIframe(){
  const hash = liveHashForStep(activeFlow().key, currentStep);
  try{ $('liveFrame').contentWindow.location.hash=hash; }catch(e){}
}
/* 이미지 매핑 */
// V10.0: 이미지 객체는 DB에서 불러온 후 로컬 스토리지에 캐시된 데이터를 사용
function ensureImgObj(){
  let o = getLS(STORAGE.IMGS, {}); 
  if (!o || Object.keys(o).length === 0) {
      o = {}; // 로컬 스토리지에 없으면 빈 객체로 초기화
  }
  const k=activeFlow().key;
  if(!o[k]) o[k]={ stepMap:{}, gallery:[] };
  // DB 저장은 setImagesToDB()에서만 호출
  return o;
}
function imgForStep(flowKey, stepIdx){
  const o=getLS(STORAGE.IMGS, {}); 
  const base64 = o?.[flowKey]?.stepMap?.[stepIdx] || '';
  return base64ToUrl(base64); 
}
// V10.0: assignImages 수정 (DB 저장 로직 포함)
function assignImages(urls, start){
  if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가

  const o=ensureImgObj(); const k=activeFlow().key; const d=o[k];
  d.gallery = (d.gallery||[]).concat(urls);
  let s=start; urls.forEach(u=>{ if(s<flowLen()){ d.stepMap[s]=u; s++; } });

  setLS(STORAGE.IMGS, o); 
  setImagesToDB(o); // ✨ DB에 저장

  localStorage.setItem(STORAGE.MODE, 'images');
  setSrcToDB(''); // ✨ DB에 저장
  setLS(STORAGE.SRC, '');

  updateLiveMode('images');
  renderThumbs(); renderImages();
}
// 썸네일 리스트 렌더링
function renderThumbs(){
  const o=ensureImgObj(); const k=activeFlow().key; const d=o[k];
  const list=$('imgList'); list.innerHTML='';
  const steps=activeFlow().steps; 

  for(let i=0;i<steps.length;i++){
    const url=imgForStep(k, i);
    const el=document.createElement('div');
    el.className='thumb'+(i===currentStep?' active':''); el.setAttribute('draggable',isAdminMode ? 'true' : 'false'); // V11.0
    el.dataset.step=i;
    el.innerHTML = (url?`<button class="del admin-only">x</button><img src="${url}">`:'') +
                   `<div class="cap">Step ${i+1}<br>${steps[i].title}${url?'':'<br>(비어 있음)'}</div>`;

    el.querySelector('.del')?.addEventListener('click', async ev=>{ // async 추가
        if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
        ev.stopPropagation(); 
        delete d.stepMap[i]; 
        setLS(STORAGE.IMGS,o); 
        await setImagesToDB(o); // ✨ DB에 저장
        renderThumbs(); renderImages(); saveState(); 
    }); 
    el.addEventListener('click', (e)=>{ 
      if(e.target.classList.contains('del')) return;
      currentStep = i; 
      renderAll(); 
      saveState();
    });
    // 썸네일 드래그앤드롭 이벤트 리스너 (순서 변경)
    el.addEventListener('drop', async ev=>{ // async 추가
      if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
      ev.preventDefault(); el.classList.remove('drag-over');
      const from=parseInt(ev.dataTransfer.getData('text/plain'),10), to=i;
      const a=d.stepMap[from], b=d.stepMap[to];
      if(a===undefined && b===undefined) return;
      d.stepMap[from]=b; d.stepMap[to]=a; 
      setLS(STORAGE.IMGS,o); 
      await setImagesToDB(o); // ✨ DB에 저장
      renderThumbs(); renderImages(); saveState(); 
    });
    list.appendChild(el);
  }
  const mappedCount = steps.filter((s, i) => d.stepMap[i]).length;
  $('imgInfo').innerText = `매핑됨: ${mappedCount}/${steps.length} 단계`;
}
$('btnPickImages').onclick=()=>$('imgFiles').click();
$('imgFiles').addEventListener('change', e=>{
  const files=Array.from(e.target.files||[]); if(!files.length) return;
  const urls=files.map(f=>URL.createObjectURL(f));
  assignImages(urls, currentStep);
});
$('btnAssignFromCurrent').onclick=async ()=>{ // async 추가
  if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
  const o=ensureImgObj(); const k=activeFlow().key; const d=o[k];
  if(!d.gallery || !d.gallery.length){ alert('먼저 이미지를 선택하세요.'); return; }
  d.stepMap={}; let s=currentStep; d.gallery.forEach(u=>{ if(s<flowLen()){ d.stepMap[s]=u; s++; } });
  setLS(STORAGE.IMGS,o); 
  await setImagesToDB(o); // ✨ DB에 저장

  localStorage.setItem(STORAGE.MODE, 'images');
  await setSrcToDB(''); // ✨ DB에 저장
  setLS(STORAGE.SRC, '');

  updateLiveMode('images'); 
  renderThumbs(); renderImages();
  saveState();
};
$('btnClearMap').onclick=async ()=>{ // async 추가
  if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
  const o=ensureImgObj(); 
  o[activeFlow().key].stepMap={}; 
  setLS(STORAGE.IMGS,o); 
  await setImagesToDB(o); // ✨ DB에 저장
  renderThumbs(); renderImages(); saveState(); 
}; 

/* 이미지 핀 (Live 이미지 창 기능) */
// V10.0: 핀 데이터는 DB에서 불러온 후 로컬 스토리지에 캐시된 데이터를 사용
async function getPins(flowKey=activeFlow().key, step=currentStep){
  const o = getLS(STORAGE.PINS, {});
  if(!o[flowKey]) o[flowKey]={}; 
  if(!o[flowKey][step]) o[flowKey][step]=[];
  return o[flowKey][step];
}
async function savePins(list, flowKey=activeFlow().key, step=currentStep){
  const o=getLS(STORAGE.PINS, {}); 
  if(!o[flowKey]) o[flowKey]={}; 
  o[flowKey][step]=list; 
  setLS(STORAGE.PINS, o); 
  await setPinsToDB(o); // ✨ DB에 영구 저장
  saveState();
}
let pinMode=false;
$('pinMode').addEventListener('change', e=>{ 
    pinMode = e.target.checked; 
});
$('btnClearPins').addEventListener('click', async ()=>{ 
    if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
    await savePins([]); renderPins(); 
}); // async 추가

$('imgBoard').addEventListener('click', async (e)=>{ // async 추가
  if(!pinMode || !isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
  if(!imgForStep(activeFlow().key, currentStep)){ alert('이 단계에 이미지가 없습니다.'); return; }
  const rect=$('imgBoard').getBoundingClientRect();
  const x=((e.clientX-rect.left)/rect.width)*100, y=((e.clientY-rect.top)/rect.height)*100;
  const text=prompt('핀 설명을 입력하세요:'); if(text===null) return;
  const list=await getPins(); // await 추가
  list.push({id:uuid(), x:+x.toFixed(2), y:+y.toFixed(2), text:text.trim()});
  await savePins(list); renderPins(); // ✨ DB에 저장

  pinMode = false;
  $('pinMode').checked = false;
});

function renderPins(){
  renderPinLayer('pinLayer', getPins());
}
function renderPinLayer(layerId, list){
  const layer=$(layerId); if(!layer) return; layer.innerHTML='';
  list.forEach((p,idx)=>{
    const pin=document.createElement('div');
    pin.className='pin'; pin.innerText=String(idx+1);
    pin.style.left=p.x+'%'; pin.style.top=p.y+'%';
    const note=document.createElement('div'); note.className='pinNote'; note.textContent=p.text||'(설명 없음)'; note.style.display='none';
    pin.addEventListener('mouseenter', ()=>{ note.style.display='block'; });
    pin.addEventListener('mouseleave', ()=>{ note.style.display='none'; });
    pin.addEventListener('click', async (ev)=>{ // async 추가
      if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
      ev.stopPropagation();
      const v=prompt('핀 수정 (비우면 삭제)', p.text||''); if(v===null) return;
      const arr=list.slice();
      if(v.trim()===''){ await savePins(arr.filter(x=>x.id!==p.id)); } else { p.text=v.trim(); await savePins(arr); } // ✨ DB에 저장
      renderPins();
    });
    const wrap=document.createElement('div'); wrap.style.position='absolute'; wrap.style.left=p.x+'%'; wrap.style.top=p.y+'%'; wrap.style.transform='translate(-50%,-50%)';
    wrap.appendChild(pin); wrap.appendChild(note); layer.appendChild(wrap);
  });
}
function renderImages(){
  const url = imgForStep(activeFlow().key, currentStep) || '';
  const img = $('stepImg'); 
  if(img) {
    img.src=url;
    img.alt = url ? activeStepData().title : "Step image (No image assigned)";
  }
  if(localStorage.getItem(STORAGE.MODE) === 'images') {
    renderPins();
  }
}
/* 이미지 캡처 기능 (기존 로직 유지) */
$('btnExportImage').addEventListener('click', ()=>{
    const target = $('mainContent');

    const originalText = $('btnExportImage').textContent;
    $('btnExportImage').textContent = '캡처 중...';
    $('btnExportImage').disabled = true;

    html2canvas(target, {
        allowTaint: true,
        useCORS: true,
        scrollY: -window.scrollY, 
        scale: 2 
    }).then(canvas => {
        const title = activeFlow().title.replace(/[^a-z0-9]/gi, '_');
        const stepName = activeStepData().title.replace(/[^a-z0-9]/gi, '_');
        const filename = `${title}_${stepName}_${new Date().getTime()}.png`;

        const link = document.createElement('a');
        link.href = canvas.toDataURL('image/png');
        link.download = filename;
        link.click();

        $('btnExportImage').textContent = originalText;
        $('btnExportImage').disabled = false;
        alert('화면 캡처(PNG)가 완료되었습니다.');
    }).catch(err => {
        console.error("캡처 실패:", err);
        $('btnExportImage').textContent = originalText;
        $('btnExportImage').disabled = false;
        alert('캡처에 실패했습니다. (콘솔 로그 확인)');
    });
});

/* V8.0: 작업 저장 (Export) 기능 - Base64 -> LZ-String 압축 적용 */
$('btnExportWork').addEventListener('click', async () => {
    // V10.0: DB에서 최신 데이터 불러와 로컬 스토리지에 캐시
    const flowData = await loadFlowsFromDB();
    const pinsData = await getPinsFromDB();
    const structPinsData = await getStructPinsFromDB();
    const srcData = await getSrcFromDB();
    const imgsData = await getImagesFromDB(); // 이미지 데이터는 Blob URL이 아닌 Base64 원본을 포함함

    const loadingOverlay = $('loadingOverlay');
    const progressBar = $('progressBar');
    const progressText = $('progressText');
    const loadingTitle = $('loadingTitle');

    loadingOverlay.style.display = 'flex';
    loadingTitle.textContent = '작업 데이터 수집 중...';
    progressBar.style.width = '0%';
    progressText.textContent = '0%';

    const exportButton = $('btnExportWork');
    const originalText = exportButton.textContent;
    exportButton.disabled = true;

    const data = {};
    const imagesToConvert = [];
    let failureCount = 0;
    const base64Map = {};

    // 1. 모든 핵심 데이터 수집 (Firebase에서 불러온 최신 데이터 사용)
    data[STORAGE.FLOWS] = JSON.stringify(flowData);
    data[STORAGE.PINS] = JSON.stringify(pinsData);
    data[STORAGE.SPINS] = JSON.stringify(structPinsData);
    data[STORAGE.SRC] = JSON.stringify(srcData);
    data[STORAGE.IMGS] = JSON.stringify(imgsData);

    // 로컬 상태만 유지
    data[STORAGE.ORDER] = localStorage.getItem(STORAGE.ORDER);
    data[STORAGE.MODE] = localStorage.getItem(STORAGE.MODE);
    data[STORAGE.STATE] = localStorage.getItem(STORAGE.STATE);

    // 2. 이미지 데이터(IMGS)에서 Blob URL을 Base64로 변환할 목록 수집 (로컬에만 남아있는 임시 데이터 처리)
    try {
        const currentImgsData = getLS(STORAGE.IMGS, {});
        for (const flowKey in currentImgsData) {
            const flowData = currentImgsData[flowKey];
            if (flowData && flowData.gallery) {
                flowData.gallery.forEach(url => {
                    if (url && url.startsWith('blob:')) {
                        imagesToConvert.push(url);
                    }
                });
            }
        }
    } catch (e) {
        console.error("Error parsing current IMGS data for export:", e);
    }

    const uniqueUrls = [...new Set(imagesToConvert)];

    // 3. Blob URL -> Base64 (압축 포함) 변환 실행
    if (uniqueUrls.length > 0) {

        loadingTitle.textContent = `이미지 ${uniqueUrls.length}개 변환 및 압축 시작`;

        try {
            const conversionPromises = uniqueUrls.map((url, index) => {
                return urlToBase64(url).then(result => {
                    const completed = index + 1;
                    const percentage = Math.round((completed / uniqueUrls.length) * 100);

                    if(completed % Math.ceil(uniqueUrls.length / 10) === 0 || completed === uniqueUrls.length) {
                         progressBar.style.width = `${percentage}%`;
                         progressText.textContent = `이미지 압축 중: ${completed}/${uniqueUrls.length} (${percentage}%)`;
                    }

                    return result;
                });
            });

            const results = await Promise.all(conversionPromises); 

            results.forEach((result) => {
                if (result.error) {
                    failureCount++;
                } else {
                    base64Map[result.url] = result.base64;
                }
            });

            progressBar.style.width = '100%';
            progressText.textContent = `이미지 압축 완료: ${uniqueUrls.length}/${uniqueUrls.length} (100%)`;
            loadingTitle.textContent = '데이터 정리 중...';

        } catch (error) {
            loadingOverlay.style.display = 'none';
            exportButton.textContent = originalText;
            exportButton.disabled = false;
            alert('치명적인 저장 오류: Base64 변환/압축 과정에서 예기치 않은 오류가 발생했습니다. (콘솔 로그 확인)');
            console.error('Base64 Conversion Error (Fatal):', error);
            return;
        }
    }

    // 4. IMGS 데이터 내의 모든 Blob URL을 압축된 Base64 문자열로 대체
    let exportImgsData = JSON.parse(data[STORAGE.IMGS] || '{}');
    for (const flowKey in exportImgsData) {
        const flowData = exportImgsData[flowKey];
        if (flowData) {
            // gallery URL 대체
            if (flowData.gallery) {
                flowData.gallery = flowData.gallery.map(url => base64Map[url] || url);
            }
            // stepMap URL 대체
            if (flowData.stepMap) {
                for (const step in flowData.stepMap) {
                    const url = flowData.stepMap[step];
                    flowData.stepMap[step] = base64Map[url] || url;
                }
            }
        }
    }

    // 5. 최종 데이터에 업데이트된 IMGS 저장 및 파일 다운로드
    data[STORAGE.IMGS] = JSON.stringify(exportImgsData);

    const dataStr = JSON.stringify(data, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });

    let filename = $('saveFileName').value.trim();
    if (filename === '') {
        filename = `knitverse_storyboard_data_${activeFlow().title.replace(/[^a-z0-9]/gi, '_')}`;
    }
    filename += `_${new Date().getTime()}.json`;

    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();

    loadingOverlay.style.display = 'none';
    exportButton.textContent = originalText;
    exportButton.disabled = false;

    if (failureCount > 0) {
        alert(`저장 완료: ${failureCount}개의 이미지를 변환하는 데 실패했습니다. (콘솔 로그 확인)`);
    } else {
        alert('작업 데이터가 JSON 파일로 성공적으로 저장되었습니다. (LZ-String 압축 적용)');
    }
});

/* V8.0: 작업 불러오기 (Import) 기능 - LZ-String 압축 해제 적용 */
$('btnImportWork').addEventListener('click', () => {
    if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
    $('workFile').click();
});
$('workFile').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;

    if (!confirm('경고: 현재 작업 내용은 모두 삭제되고, 선택한 파일의 데이터로 덮어쓰여집니다. 계속하시겠습니까?')) {
        $('workFile').value = ''; 
        return;
    }

    const reader = new FileReader();
    reader.onload = async function(event) { // async 추가
        try {
            const importedData = JSON.parse(event.target.result);

            // 1. 모든 데이터를 Firebase에 덮어쓰기
            const promises = STORAGE.ALL_KEYS.map(key => {
                if (importedData[key] !== undefined) {
                    let value = JSON.parse(importedData[key]);
                    return setDB(key, value); // DB에 직접 저장
                }
                return Promise.resolve();
            });

            await Promise.all(promises);

            // 2. 로컬 스토리지에 임시 상태 복원 (Import 후 새로고침 시 Firebase에서 데이터를 다시 불러올 것임)
            STORAGE.ALL_KEYS.forEach(key => {
                if (importedData[key] !== undefined) {
                    localStorage.setItem(key, importedData[key]);
                }
            });

            alert('작업 데이터 및 이미지가 Firebase에 성공적으로 저장되었습니다. 페이지를 새로고침하여 적용합니다.');
            window.location.reload(); 

        } catch (error) {
            alert('오류: 파일을 읽거나 분석하는 데 실패했습니다. 올바른 JSON 파일인지 확인하십시오.');
            console.error('Import Error:', error);
        }
    };
    reader.readAsText(file);
});


/* 기타 편집 도우미 함수 */
const $ = id => document.getElementById(id);
const activeFlow = () => flows[currentFlowIdx];
const flowLen = () => activeFlow().steps.length;
const activeStepData = () => activeFlow().steps[currentStep];

/* 흐름 제어 */
$('btnPrev').onclick = () => { if(currentStep>0){ currentStep--; renderAll(); navIframe(); saveState(); } };
$('btnNext').onclick = () => { if(currentStep<flowLen()-1){ currentStep++; renderAll(); navIframe(); saveState(); } };

/* 렌더링 통합 함수 */
function updateLiveMode(mode){
  const iframeActive = mode === 'iframe';
  const imagesActive = mode === 'images';

  $('iframePane').style.display = iframeActive ? 'block' : 'none';
  $('imagesPane').style.display = imagesActive ? 'block' : 'none';

  if(iframeActive){
    const src = getSrc();
    $('liveFrame').src = src; 
    $('srcText').value = src;
    $('srcStatus').innerText = src ? `현재: ${src}` : '현재: 연결되지 않음';
    navIframe();
  } else if (imagesActive) {
    renderImages();
  }

  localStorage.setItem(STORAGE.MODE, mode);
}

function renderAll(){
  buildFlowList();
  renderStructure();
  renderThumbs();
  // updateLiveMode는 현재 로컬 상태를 따름
  updateLiveMode(localStorage.getItem(STORAGE.MODE) || (getSrc()?'iframe':'images')); 
}

/* Flow 관리 기능 (V5.0 로직 유지 - DB 연동 추가) */
async function buildFlowList(){ // async 추가
  const list=$('flowList'); list.innerHTML='';
  const currentKey = activeFlow().key;

  flows.forEach((f,i)=>{
    const el=document.createElement('div');
    el.className='flow'+(i===currentFlowIdx?' active':''); el.setAttribute('draggable',isAdminMode ? 'true' : 'false'); // V11.0
    el.dataset.index=i;
    el.innerHTML=`
      <strong>${f.title}</strong>
      <div class="meta">${f.steps.length} steps</div>
      ${isAdminMode ? `<div class="reord">REORDER</div>` : ''}
    `;
    el.onclick=()=>{ currentFlowIdx=i; currentStep=0; renderAll(); saveState(); };

    // 드래그앤드롭 이벤트 리스너 (순서 변경)
    el.addEventListener('dragstart', e=>{ e.dataTransfer.setData('text/plain', i); el.classList.add('dragging'); });
    el.addEventListener('dragend', e=>{ el.classList.remove('dragging'); });
    el.addEventListener('dragover', e=>{ e.preventDefault(); el.classList.add('drag-over'); });
    el.addEventListener('dragleave', e=>{ el.classList.remove('drag-over'); });
    el.addEventListener('drop', async e=>{ // async 추가
      if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
      e.preventDefault(); el.classList.remove('drag-over');
      const from=parseInt(e.dataTransfer.getData('text/plain'),10), to=i;
      if(from===to) return;
      const [movedItem]=flows.splice(from,1); flows.splice(to,0,movedItem);
      currentFlowIdx=to; 

      await saveFlowsToDB(flows); // ✨ DB에 저장
      setLS(STORAGE.ORDER, flows.map(f=>f.key)); // 로컬 순서도 업데이트
      renderAll(); saveState();
    });
    list.appendChild(el);
  });
}

$('btnAddFlow').addEventListener('click', async ()=>{ // async 추가
  if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
  const title = prompt('새 플로우 제목을 입력하세요:'); if(!title) return;
  const newFlow = { key: uuid(), title: title, map: ['step1'], steps:[{title:'Step 1', body:'새로 추가된 첫 번째 단계입니다.', slots:activeStepData().slots}] };
  flows.push(newFlow); currentFlowIdx=flows.length-1; currentStep=0;

  await saveFlowsToDB(flows); // ✨ DB에 저장
  setLS(STORAGE.ORDER, flows.map(f=>f.key));
  renderAll(); saveState();
});
$('btnRenameFlow').addEventListener('click', async ()=>{ // async 추가
  if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
  const f = activeFlow();
  const newTitle = prompt('플로우 이름 변경:', f.title); if(!newTitle) return;
  f.title = newTitle;

  await saveFlowsToDB(flows); // ✨ DB에 저장
  renderAll(); saveState();
});
$('btnDeleteFlow').addEventListener('click', async ()=>{ // async 추가
  if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
  const f = activeFlow();
  if(flows.length<=1){ alert('최소 1개의 플로우가 필요합니다.'); return; }
  if(!confirm(`플로우 "${f.title}"와 모든 단계/이미지 매핑 정보를 삭제할까요?`)) return;

  // 이미지/핀 데이터도 삭제 (로컬/DB)
  const imgs = getLS(STORAGE.IMGS, {}); delete imgs[f.key]; setLS(STORAGE.IMGS, imgs); await setImagesToDB(imgs);
  const pins = getLS(STORAGE.PINS, {}); delete pins[f.key]; setLS(STORAGE.PINS, pins); await setPinsToDB(pins);
  const spins = getLS(STORAGE.SPINS, {}); delete spins[f.key]; setLS(STORAGE.SPINS, spins); await setStructPinsToDB(spins);

  flows.splice(currentFlowIdx, 1);
  if(currentFlowIdx>=flows.length) currentFlowIdx=flows.length-1;
  currentStep=0;

  await saveFlowsToDB(flows); // ✨ DB에 저장
  setLS(STORAGE.ORDER, flows.map(f=>f.key));
  renderAll(); navIframe(); saveState();
});

// V6.0: 단계 복제 기능 추가 (DB 연동)
function cloneStep(){
    if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
    const f = activeFlow();
    const s = f.steps[currentStep];

    // 새로운 단계 생성: 현재 단계의 데이터를 깊은 복사
    const newStep = JSON.parse(JSON.stringify(s));
    newStep.title = `Copy of ${s.title}`;

    // 새로운 맵 키 생성
    const newMapKey = s.map.split('_')[0] + uuid().slice(0, 4);

    // 현재 단계 다음 위치에 삽입
    f.steps.splice(currentStep + 1, 0, newStep);
    f.map.splice(currentStep + 1, 0, newMapKey);

    // 새 단계로 이동
    currentStep++;

    // 이미지 매핑 및 핀 정보 처리
    // 복제된 단계는 이미지 매핑과 핀 정보를 가지지 않음

    saveFlowsToDB(flows).then(() => { // DB에 저장
        renderAll(); 
        navIframe(); 
        saveState();
    });
}

// V7.0: 단계 추가/삭제/이름 변경 로직 (DB 연동)
async function addNewStep(){ // async 추가
    if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
    const f = activeFlow();
    const nextStepTitle = prompt('새 단계의 이름을 입력하세요:') || 'New Step';
    const newMapKey = nextStepTitle.toLowerCase().replace(/[^a-z0-9]/g, '_').slice(0, 10) + uuid().slice(0, 4);

    const newStep = {
        title: nextStepTitle,
        body: '새로 추가된 단계입니다.',
        // 현재 단계의 슬롯을 복사 (깊은 복사)
        slots: activeStepData().slots ? JSON.parse(JSON.stringify(activeStepData().slots)) : [
            {key:'core', name:'핵심 요소', content:'핵심 요소'},
            {key:'link', name:'연결', content:'다음 화면으로 넘어가는 트리거'},
            {key:'metric', name:'메트릭', content:'전환/이탈 포인트, GA 이벤트'}
        ]
    };

    f.steps.splice(currentStep+1, 0, newStep);
    f.map.splice(currentStep+1, 0, newMapKey);
    currentStep++;

    await saveFlowsToDB(flows); // ✨ DB에 저장
    renderAll(); navIframe(); saveState();
}

// V7.0: 삭제 시 핀/이미지/구조체 핀 인덱스 조정 헬퍼
function shiftAfterDelete(flowKey, delIdx){
    const shiftData = (data, storageKey, stepMapKey) => {
        const flowData = data[flowKey];
        if (!flowData) return;

        // 1. 이미지 매핑 (stepMapKey는 'stepMap' 혹은 'pins')
        const originalMap = flowData[stepMapKey] || {};
        const newMap = {};

        Object.keys(originalMap).forEach(key => {
            const idx = parseInt(key, 10);
            if (idx < delIdx) {
                newMap[idx] = originalMap[key];
            } else if (idx > delIdx) {
                newMap[idx - 1] = originalMap[key];
            }
        });
        flowData[stepMapKey] = newMap;
    };

    const updateDB = (storageKey) => {
        if (storageKey === STORAGE.IMGS) return setImagesToDB(getLS(storageKey, {}));
        if (storageKey === STORAGE.PINS) return setPinsToDB(getLS(storageKey, {}));
        if (storageKey === STORAGE.SPINS) return setStructPinsToDB(getLS(storageKey, {}));
        return Promise.resolve();
    };

    // 이미지 매핑 조정 (로컬 캐시)
    const imgs = getLS(STORAGE.IMGS, {}); shiftData(imgs, STORAGE.IMGS, 'stepMap'); setLS(STORAGE.IMGS, imgs); updateDB(STORAGE.IMGS);

    // 이미지 핀 조정 (로컬 캐시)
    const pins = getLS(STORAGE.PINS, {}); shiftData(pins, STORAGE.PINS, 'pins'); setLS(STORAGE.PINS, pins); updateDB(STORAGE.PINS);

    // 구조체 핀 조정 (로컬 캐시)
    const spins = getLS(STORAGE.SPINS, {}); shiftData(spins, STORAGE.SPINS, delIdx); setLS(STORAGE.SPINS, spins); updateDB(STORAGE.SPINS);
}


function renameStep(){
    if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
    const f = activeFlow();
    const s = f.steps[currentStep];
    const next = (prompt('단계 이름 변경:', s.title)||'').trim();
    if(!next) return;
    s.title = next;
    saveFlowsToDB(flows).then(() => { // DB에 저장
        renderAll(); 
        saveState();
    });
}

function deleteStep(){
    if (!isAdminMode) return; // V11.0: 관리자 모드 아닐 시 편집 불가
    const f = activeFlow();
    if(f.steps.length<=1){ alert('최소 1단계는 필요합니다.'); return; }
    if(!confirm(`현재 단계 "${f.steps[currentStep].title}" 를 삭제할까요?`)) return;

    const delIdx = currentStep;
    shiftAfterDelete(f.key, delIdx); // 이미지/핀 인덱스 조정

    f.steps.splice(delIdx,1);
    f.map.splice(delIdx,1);

    if(currentStep>=f.steps.length) currentStep=f.steps.length-1;

    saveFlowsToDB(flows).then(() => { // DB에 저장
        renderAll(); 
        navIframe(); 
        saveState();
    });
}

// V5.0: Structure 툴바에 단계 관리 버튼 연결
$('btnStepAdd').addEventListener('click', addNewStep);
$('btnStepClone').addEventListener('click', cloneStep); 
$('btnStepRename').addEventListener('click', renameStep);
$('btnStepDelete').addEventListener('click', deleteStep);


/* 초기 시작 */
(async function init(){
  checkAdminMode(); // V11.0: 관리자 모드 확인 및 설정
  await initFlows(); // Firebase 데이터 로드가 완료될 때까지 대기
  loadState(); // 로컬 상태 복원

  const src = getSrc(); 
  // V5.5: 초기 로드 시 Iframe 소스가 있으면 'iframe' 모드로 시작, 아니면 'images' 모드로 시작
  const mode = localStorage.getItem(STORAGE.MODE) || (src ? 'iframe' : 'images');

  // V11.0: isAdminMode가 비활성화되면 모든 편집 버튼을 숨겨야 하므로, 
  // 이전에 initFlows에서 checkAdminMode()가 호출되었으므로 renderAll()이 최종 UI를 결정합니다.

  renderAll(); 
  navIframe();
})();

</script>
</body>
</html>