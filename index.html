<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Knitverse · Hybrid Storyboard v9.0 (Firebase Sync)</title>
<!-- 🗑️ 기존 LZ-String 및 호환성 SDK 제거, 최신 모듈 방식 SDK 추가 -->
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;800&family=Noto+Sans+KR:wght@400;600;800&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
<!-- 🔥 Firebase v9 CDN 모듈 스크립트 추가 (Firestore, Storage, App) -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
    import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";
    import { getStorage, ref, uploadString, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-storage.js";

    // 전역 변수로 노출하여 아래 <script>에서 사용 가능하게 합니다.
    window.initializeApp = initializeApp;
    window.getFirestore = getFirestore;
    window.doc = doc;
    window.setDoc = setDoc;
    window.onSnapshot = onSnapshot;
    window.getStorage = getStorage;
    window.ref = ref;
    window.uploadString = uploadString;
    window.getDownloadURL = getDownloadURL;
    window.deleteObject = deleteObject;
</script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script> 
<style>
  :root{ --bg:#0b0c10; --panel:#10151b; --card:#141c26; --text:#eaf2ff; --muted:#a9b7c6; --blue:#35d0ff; --gold:#ffd54f; --line:#223244; }
  *{box-sizing:border-box}
  body{margin:0;background:radial-gradient(1200px 800px at 80% -10%, #16212c 0%, var(--bg) 55%);color:var(--text);
       font:14px/1.6 'Noto Sans KR', system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
  header{position:sticky;top:0;z-index:20;background:rgba(10,14,20,.85);backdrop-filter:blur(8px);border-bottom:1px solid #162433;
         display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 14px}
  .brand{font-family:'Orbitron';letter-spacing:.14em;color:#35d0ff;font-weight:800;text-transform:uppercase;text-shadow:0 0 10px #35d0ff77}
  .wrap{display:grid;grid-template-columns:400px 1fr;gap:14px;padding:14px}
  @media(max-width:1400px){.wrap{grid-template-columns:1fr}}
  aside{background:var(--panel);border:1px solid #1b2a3a;border-radius:14px;padding:12px;overflow-y:auto;max-height:calc(100vh - 28px - 48px)}
  .section-title{margin:6px 0 8px;font-weight:800;color:#d6e6ff}
  .flow-tools{display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap}
  .flow-list{display:grid;gap:8px}
  .flow{background:linear-gradient(180deg,#0f141b,#0f1822);border:1px solid #203044;border-radius:12px;padding:10px;cursor:grab;position:relative}
  .flow.active{border-color:var(--gold);box-shadow:0 0 0 2px #ffd54f33}
  .flow.drag-over{outline:2px dashed #35d0ff}
  .flow .reord{position:absolute;top:8px;right:8px;font-size:10px;color:#96b}
  /* V6.0: 플로우 목록의 단계 수 표시 제거를 위해 meta 스타일 숨김 */
  .meta{color:#9eb0c6;font-size:12px;line-height:1.4; display: none;} 
  .meta-content{min-height:24px}
  .picker{display:grid;gap:8px;background:#0f141b;border:1px solid #203044;border-radius:12px;padding:10px;margin-top:10px}
  input[type="text"]{width:100%;padding:8px;border-radius:8px;border:1px solid #223244;background:#0b1219;color:#eaf2ff;font-family:'Roboto Mono'}
  .radio{display:flex;gap:12px;align-items:center;margin:6px 0 2px}
  .small{font-size:12px;color:#9fb0c6}
  
  /* 썸네일 영역 */
  .thumbs-section{margin-top:16px; padding-top:16px; border-top:1px solid var(--line);}
  .thumbs{display:grid;grid-template-columns:repeat(auto-fill,minmax(90px,1fr));gap:8px;margin-top:8px}
  .thumb{border:1px solid var(--line);border-radius:10px;padding:6px;background:#0b1219;text-align:center;position:relative;cursor:pointer}
  .thumb.active{border-color:var(--blue);box-shadow:0 0 0 2px #35d0ff33;}
  .thumb[draggable="true"]{cursor:grab}
  .thumb.drag-over{outline:2px dashed #35d0ff}
  .thumb img{max-width:100%;max-height:68px;border-radius:6px;display:block;margin:0 auto 6px}
  .thumb .cap{font-size:11px;color:#cfe2ff}
  .thumb .del{position:absolute;top:6px;right:6px;background:#150e0e;border:1px solid #4a2020;color:#ff9b9b;border-radius:8px;font-size:11px;padding:2px 6px;cursor:pointer;z-index:10}
  
  main{background:var(--panel);border:1px solid #1b2a3a;border-radius:14px;padding:0;overflow:hidden}
  .toolbar{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:12px;border-bottom:1px solid #192737}
  .crumbs{color:#b9c7d8;font-size:12px}
  .btn{background:#0f141b;border:1px solid #223244;color:#eaf2ff;padding:8px 12px;border-radius:10px;cursor:pointer;flex-shrink:0}
  .btn.primary{border-color:var(--gold);color:#111;background:var(--gold);font-weight:800}
  .btn.danger{border-color:#4a2020;color:#ff9b9b;background:#150e0e;}
  
  /* V6.0: 이미지 선택 버튼 강조 스타일 */
  .btn.asset-primary{
      background: #ff9800; /* 주황색 배경 */
      border-color: #ffb74d; /* 밝은 주황색 테두리 */
      color: #111; /* 진한 텍스트 */
      font-weight: 800; 
      box-shadow: 0 0 8px #ff980044;
  }
  
  .stage{padding:14px}
  .unified-stage{display:grid;grid-template-columns:1fr 1fr;gap:14px;} 
  @media(max-width:1400px){.unified-stage{grid-template-columns:1fr}}
  .screen-panel{position:relative;background:linear-gradient(180deg,#0f141b,#101a24);border:1px solid #223244;border-radius:12px;padding:14px;min-height:480px;box-shadow:0 14px 44px #0008;height:100%}
  .stage-wrap{display:grid;grid-template-rows:minmax(480px, auto) 1fr;gap:14px;}
  
  /* Structure UI */
  .grid{display:grid;grid-template-columns:1fr;gap:10px;margin-top:14px}
  .card{position:relative;background:#182330;border-left:4px solid var(--blue);border-radius:8px;padding:10px 12px;transition:all .1s; cursor:grab;}
  .card.dragging{ opacity: 0.4; } 
  .card.drag-over{ outline: 2px dashed var(--gold); }
  .card:hover{border-left-color:var(--gold);background:#1d2938}
  .card strong{color:var(--blue);font-size:12px;text-transform:uppercase;letter-spacing:.05em;display:block;margin-bottom:2px}
  .card[data-slot*="link"] strong{color:#c7ff35} 
  .card[data-slot*="metric"] strong{color:#ff9933} 
  .meta-content{color:var(--text);font-size:14px;font-weight:600;line-height:1.4;min-height:20px}
  
  /* HOME (제목) 및 설명 편집 가능 스타일 */
  h2{margin-top:0;font-size:1.6em;border-bottom:1px solid var(--line);padding-bottom:10px;margin-bottom:10px;color:var(--gold);cursor:pointer}
  .struct-desc{color:#d6e6ff;font-size:14px;line-height:1.5;margin-bottom:20px;cursor:pointer}
  
  .progress{height:8px;background:#0c1219;border:1px solid #1e2b3a;border-radius:999px;overflow:hidden;margin:8px 0 0}
  .bar{height:100%;background:linear-gradient(90deg,#35d0ff,#ffd54f);width:0%}
  
  iframe{width:100%;height:100%;min-height:540px;border:1px solid #223244;border-radius:12px;background:#0b0c10}
  .imgStageWrap{background:linear-gradient(180deg,#0f141b,#0f1721);border:1px solid #203044;border-radius:12px;padding:10px;height:100%;}
  /* V5.4: Live 이미지 툴바 및 핀 버튼 영역 */
  .imgTools{display:flex;gap:8px;align-items:center;margin-bottom:6px;flex-wrap:wrap;padding: 0 4px;} 
  /* V5.4: 스크롤바 방지 CSS 강화 */
  .imgBoard{position:relative;display:flex;align-items:center;justify-content:center;min-height:540px;background:#0b0c10;border:1px dashed #234;border-radius:12px;
            max-width:100%; max-height:100%; overflow:hidden;} /* overflow:hidden 추가 */
  .imgBoard img{max-width:100%;max-height:100%;width:auto;height:auto;border-radius:8px;display:block;object-fit:contain;}
  
  .pinLayer{position:absolute;inset:0;pointer-events:none}
  .pin{position:absolute;transform:translate(-50%,-50%);background:#ffd54f;color:#111;border:2px solid #111;border-radius:999px;width:16px;height:16px;display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:800;pointer-events:auto;cursor:pointer}
  .pin:hover{box-shadow:0 0 0 4px #ffd54f33}
  .pinNote{position:absolute;transform:translate(8px,-50%);background:#141c26;color:#eaf2ff;border:1px solid #223244;border-radius:8px;padding:6px;min-width:160px;max-width:260px;font-size:12px}
  .hint{font-size:12px;color:#9fb0c6}
  
  /* Structure 툴바: 단계 관리 버튼 통합 */
  .structTools{position:relative;display:flex;gap:8px;align-items:center;flex-wrap:wrap;padding-bottom:10px;margin-bottom:10px;border-bottom:1px solid var(--line);}
  .slot-tools{margin-top:10px;padding-top:10px;border-top:1px dashed var(--line);}
</style>
</head>
<body>
<header>
  <div class="brand">KNITVERSE · Hybrid Storyboard V9.0</div>
</header>
<div class="wrap" id="mainWrapper">
  <aside>
    <div class="section-title">플로우 선택 (드래그로 순서 변경)</div>
    <div class="flow-tools">
        <button class="btn" id="btnAddFlow">플로우 추가</button>
        <button class="btn" id="btnRenameFlow">이름 변경</button>
        <button class="btn danger" id="btnDeleteFlow">삭제</button>
    </div>
    <div class="flow-list" id="flowList"></div>

    <div class="section-title" style="margin-top:16px">Live Demo 소스</div>
    <div class="picker">
      <label>Iframe (HTML) 파일 경로/이름 입력</label>
      <div id="srcIframeBox">
        <input id="srcText" type="text" placeholder="예: knitverse_mvp_skin_pro.html 또는 ./sub/app.html">
        <button class="btn" id="applySrc">적용</button>
        <div class="small">또는 파일 선택 →</div>
        <input id="srcFile" type="file" accept=".html,.htm">
        <div class="small" id="srcStatus">현재: 연결되지 않음</div>
      </div>
    </div>
    
    <div class="thumbs-section">
        <div class="section-title">단계별 이미지 삽입 (Step Images)</div>
        <div class="small">이미지를 여기에 업로드하면 자동으로 이미지 모드로 전환됩니다.</div>
        <div class="imgTools" style="padding: 10px 0;">
            <button class="btn asset-primary" id="btnPickImages">이미지 선택</button>
            <button class="btn" id="btnAssignFromCurrent">현재 단계부터 재할당</button>
            <button class="btn danger" id="btnClearMap">이 플로우 매핑 초기화</button>
            <input id="imgFiles" type="file" accept="image/*" multiple style="display:none">
            <div class="small" id="imgInfo" style="flex-basis: 100%;"></div>
        </div>
        
        <div class="thumbs" id="imgList"></div>
        <div class="small">드래그앤드롭으로 이미지 순서 변경 가능. 썸네일 클릭 시 해당 단계로 이동.</div>
    </div>

    <!-- V9.0: JSON 저장/불러오기 섹션 숨김 (Firebase가 실시간으로 저장하므로) -->
    <div class="thumbs-section" style="display:none">
        <div class="section-title">작업 저장 / 불러오기 (JSON)</div>
        <label class="small" style="margin-top: 8px;">저장할 파일명 (확장자 제외)</label>
        <input id="saveFileName" type="text" placeholder="예: knitverse_project_final" style="margin-bottom: 8px;">
        
        <button class="btn primary" id="btnExportWork">작업 저장 (JSON)</button> 

        <div style="height: 10px;"></div>
        <button class="btn" id="btnImportWork">작업 불러오기 (파일 선택)</button>
        <input id="workFile" type="file" accept=".json" style="display:none">
        <div class="small">저장된 JSON 파일을 불러와 작업 환경을 복원합니다.</div>
    </div>
    
  </aside>
  <main id="mainContent">
    <div class="toolbar">
      <div class="crumbs" id="crumbs">HOME</div>
      <div class="controls">
        <button class="btn" id="btnExportImage">화면 캡처 (PNG)</button> 
        <button class="btn" id="btnPrev">← 이전</button>
        <button class="btn primary" id="btnNext">다음 →</button>
      </div>
    </div>

    <div class="stage unified-stage">
      
      <div id="structPanel" class="screen-panel">
        <div class="structTools">
          <button class="btn" id="btnStepAdd">단계 추가</button>
          <button class="btn" id="btnStepClone">현재 단계 복제</button>
          <button class="btn" id="btnStepRename">이름 변경</button>
          <button class="btn danger" id="btnStepDelete">단계 삭제</button>
          <div style="flex-basis:100%; height:8px;"></div>
          <label class="small"><input type="checkbox" id="structPinMode"> 핀 추가</label> 
          <button class="btn" id="btnStructClearPins">핀 삭제</button>
        </div>
        <div id="structBody"></div>
        <div class="pinLayer" id="structPinLayer"></div>
      </div>

      <div class="stage-wrap">
        <div id="iframePane" class="imgStageWrap" style="display:none">
          <div class="imgTools">
            <span class="hint">Live Demo (Iframe) 영역입니다. (Step Images가 우선입니다.)</span>
          </div>
          <iframe id="liveFrame"></iframe>
          <div class="hint">해시 내비(#home/#shop/#classes/#mypage)로 스텝 이동에 맞춰 연동합니다.</div>
        </div>
        <div id="imagesPane" class="imgStageWrap" style="display:none">
          <div class="imgTools">
            <label><input type="checkbox" id="pinMode"> 핀 추가</label>
            <button class="btn" id="btnClearPins">핀 삭제</button>
            <span class="hint">이미지 위를 클릭하면 핀과 설명을 추가할 수 있어요.</span>
          </div>
          <div class="imgBoard" id="imgBoard">
            <img id="stepImg" alt="Step image">
            <div class="pinLayer" id="pinLayer"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="progress" style="margin-top:14px"><div class="bar" id="bar"></div></div>
    <footer id="footer"></footer>
  </main>
</div>

<div id="loadingOverlay" style="position:fixed; inset:0; background:rgba(0,0,0,.8); z-index:9999; display:none; flex-direction:column; justify-content:center; align-items:center; color:white; font-size:16px;">
    <div style="width:300px; padding:20px; background:#141c26; border-radius:12px; border:1px solid #35d0ff;">
        <div style="font-weight:bold; margin-bottom:10px;" id="loadingTitle">작업 데이터 저장 준비 중...</div>
        <div id="progressBarContainer" style="height:10px; background:#0b0c10; border-radius:5px; overflow:hidden;">
            <div id="progressBar" style="height:100%; width:0; background:#ffd54f;"></div>
        </div>
        <div id="progressText" style="margin-top:10px; text-align:right;">0%</div>
    </div>
</div>


<script>
/* =========================
   플로우 정의 (5개) 
========================= */
const BASE_FLOWS=[
 {key:'fan',     title:'팬 · 구매 플로우', map:['home','shop','product','checkout','done'], 
  steps:[
   {title:'HOME',body:'히어로 배너에서 상품 진입', slots:[{key:'core', name:'핵심 요소', content:'CTA · 사용자 목표 · 성공 시그널'},{key:'link', name:'연결', content:'쇼핑 리스트로 이동'},{key:'metric', name:'메트릭', content:'Home to Shop 클릭률'}]},
   {title:'SHOP',body:'트렌딩 상품 리스트', slots:[{key:'core', name:'상품 리스트 핵심', content:'상품 리스트 핵심'},{key:'link', name:'상품 상세로 이동', content:'상품 상세로 이동'},{key:'metric', name:'상품 조회율', content:'상품 조회율'}]},
   {title:'상세',body:'상품 상세 페이지', slots:[{key:'core', name:'상품 상세 핵심', content:'상품 상세 핵심'},{key:'link', name:'체크아웃으로 이동', content:'체크아웃으로 이동'},{key:'metric', name:'장바구니 담기율', content:'장바구니 담기율'}]},
   {title:'체크아웃',body:'결제 요약 화면', slots:[{key:'core', name:'결제 핵심', content:'결제 핵심'},{key:'link', name:'주문 완료', content:'주문 완료'},{key:'metric', name:'결제 성공률', content:'결제 성공률'}]},
   {title:'완료',body:'주문 완료', slots:[{key:'core', name:'완료 핵심', content:'완료 핵심'},{key:'link', name:'마이페이지로 이동', content:'마이페이지로 이동'},{key:'metric', name:'재방문 유도', content:'재방문 유도'}]}
  ]},
 {key:'rookie',  title:'루키 · 성장 플로우', map:['home','apply','klgc','upload','publish'], steps:[{title:'HOME',body:'APPLY 클릭'},{title:'Apply Form',body:'아티스트 지원 폼'},{title:'K-LGC',body:'4주 커리큘럼 단계'},{title:'Upload',body:'상품 업로드'},{title:'Publish',body:'상품 공개 완료'}]},
 {key:'learner', title:'학습자 · 클래스 플로우', map:['home','classes','detail','enroll','play'], steps:[{title:'HOME',body:'클래스 탭 클릭'},{title:'Class List',body:'강의 목록'},{title:'Detail',body:'강의 상세 설명'},{title:'Enroll',body:'수강 등록'},{title:'Player',body:'강의 재생'}]},
 {key:'creator', title:'액티브/마스터 작가 플로우', map:['home','classes','create','sell','legacy'], steps:[{title:'HOME',body:'MY PAGE에서 크리에이터 허브 진입'},{title:'클래스 개설',body:'커리큘럼/가격/언어 설정'},{title:'상품화',body:'키트/도안 번들 구성 · 재고'},{title:'판매/프로모션',body:'런칭 · 팬/커뮤니티 프로모션'},{title:'레거시 축적',body:'멘토링/평가 · 레거시 스코어 상승'}]},
 {key:'support', title:'서포터즈 플로우', map:['home','community','apply','board','credit'], steps:[{title:'HOME',body:'COMMUNITY 진입'},{title:'Supporter Hub',body:'역할 선택/가용성 설정'},{title:'Apply',body:'프로필 제출'},{title:'Matching Board',body:'프로젝트 매칭/승인'},{title:'크레딧 & 보상',content:'K-Points 적립/정산'}]}
];

/* =========================
   Firebase 초기화 & 상태 정의
========================= */

// 💡 [여기를 주목!] 복사해주신 Firebase Config 정보가 정확히 적용되었습니다.
const firebaseConfig = {
    apiKey: "AIzaSyD9SfwCbyHlGBr8GtbTx5bNvRB4g3VazfU",
    authDomain: "knitverse-storyboard-sync.firebaseapp.com",
    projectId: "knitverse-storyboard-sync",
    storageBucket: "knitverse-storyboard-sync.firebasestorage.app",
    messagingSenderId: "638143951233",
    appId: "1:638143951233:web:d48e4eb1fd59f595d0f880"
};

// 💡 Firebase 서비스 객체 정의
const app = window.initializeApp(firebaseConfig);
const db = window.getFirestore(app);
const storage = window.getStorage(app); 

// 💡 현재 플로우 데이터가 저장될 Firestore의 경로를 정의합니다.
//    이 경로는 모든 기획자가 동일하게 사용하며 실시간으로 동기화됩니다.
const FIREBASE_DOC_PATH = 'teams/knitverse';
const FLOWS_REF = window.doc(db, FIREBASE_DOC_PATH, 'flows'); 
const PINS_REF = window.doc(db, FIREBASE_DOC_PATH, 'pins'); 
const SPINS_REF = window.doc(db, FIREBASE_DOC_PATH, 'structPins'); 
const STATE_REF = window.doc(db, FIREBASE_DOC_PATH, 'state');
const IMAGES_REF = window.doc(db, FIREBASE_DOC_PATH, 'imgSrc');

/* =========================
   상태 & 저장 키 + 헬퍼
========================= */
let flows = [];
let currentFlowIdx = 0;
let currentStep = 0;

let pins = {}; // 이미지 핀 데이터 (Firestore 동기화)
let structPinsData = {}; // 구조 핀 데이터 (Firestore 동기화)
let imgSrc = {}; // 이미지가 Storage URL로 저장될 맵 (Firestore 동기화)

const STORAGE = {
  SRC:   'kv_v50_src', // iframe 경로만 로컬 저장
};

function $(id){ return document.getElementById(id); }
function uuid(){ return Math.random().toString(36).slice(2,10); }
function activeFlow(){ return flows[currentFlowIdx]; }
function flowLen(){ return activeFlow()?.steps?.length || 0; }
function activeStepData(){ return activeFlow()?.steps?.[currentStep]; }

/* =========================
   Firebase 동기화 로직
========================= */

// V9.0: 데이터 저장 로직 (모든 변경은 이 함수를 통해 Firebase에 반영됩니다.)
function saveFlows(flowsArr = flows) {
    if (flowsArr && flowsArr.length > 0) {
        window.setDoc(FLOWS_REF, { flows: flowsArr }, { merge: true })
            .catch(e => console.error("Error saving flows:", e));
    }
}

function saveState() {
    // 흐름 인덱스가 유효할 때만 저장
    if (currentFlowIdx < 0 || currentFlowIdx >= flows.length) return; 
    window.setDoc(STATE_REF, { flowIdx: currentFlowIdx, stepIdx: currentStep }, { merge: true })
        .catch(e => console.error("Error saving state:", e));
}

// 초기화 시 Firestore 리스너를 시작합니다.
function startDataListeners() {
    // 1. FLOWS (플로우 구조, 단계, 슬롯 콘텐츠) 리스너
    window.onSnapshot(FLOWS_REF, (doc) => {
        const data = doc.data();
        if (data && Array.isArray(data.flows) && data.flows.length > 0) {
            flows = data.flows;
            // V5.5 호환성: 슬롯이 없으면 기본 슬롯 추가
            flows.forEach(f => {
                f.steps.forEach(s => {
                    if(!s.slots){
                        s.slots = [
                           {key:'core', name:'핵심 요소', content: s.core || '핵심 요소'},
                           {key:'link', name:'연결', content: '다음 화면으로 넘어가는 트리거'},
                           {key:'metric', name:'메트릭', content: '전환/이탈 포인트, GA 이벤트'}
                       ];
                    }
                    if(!s.body) s.body = '설명 없음';
                });
            });
            buildFlowList();
            renderAll();
        } else {
            // Firestore에 데이터가 없으면 BASE_FLOWS로 초기화하고 저장합니다.
            if(flows.length === 0) {
                console.log('No flows data in Firestore. Initializing...');
                flows = JSON.parse(JSON.stringify(BASE_FLOWS));
                saveFlows(flows);
            }
        }
    });

    // 2. PINS (이미지 핀) 리스너
    window.onSnapshot(PINS_REF, (doc) => {
        const data = doc.data();
        if (data) {
            pins = data;
            renderPins();
        }
    });

    // 3. STRUCT PINS (구조 핀) 리스너
    window.onSnapshot(SPINS_REF, (doc) => {
        const data = doc.data();
        if (data) {
            structPinsData = data;
            renderStructPinLayer();
        }
    });
    
    // 4. IMAGE SRC (이미지 URL 맵) 리스너
    window.onSnapshot(IMAGES_REF, (doc) => {
        const data = doc.data();
        if (data) {
            imgSrc = data;
            renderThumbs();
            renderImages();
        }
    });

    // 5. STATE (현재 위치: flowIdx, stepIdx) 리스너
    window.onSnapshot(STATE_REF, (doc) => {
        const data = doc.data();
        if (data) {
            // 데이터 수신 시, 현재 상태를 업데이트하고 화면을 다시 그립니다.
            currentFlowIdx = Math.min(Math.max(0, data.flowIdx || 0), flows.length - 1);
            currentStep = Math.min(Math.max(0, data.stepIdx || 0), flowLen() - 1);
            renderAll();
        }
    });
}

function initFlows(){
    startDataListeners();
}

/* =========================
   Structure: 핀/메모 + 카드 데이터 (Firestore 연동)
========================= */
function structPins(flowKey = activeFlow().key, step = currentStep){
  if(!structPinsData[flowKey]) structPinsData[flowKey]={};
  if(!structPinsData[flowKey][step]) structPinsData[flowKey][step]=[];
  return structPinsData[flowKey][step];
}
function setStructPins(list, flowKey = activeFlow().key, step = currentStep){
  if(!structPinsData[flowKey]) structPinsData[flowKey]={};
  structPinsData[flowKey][step]=list;
  
  window.setDoc(SPINS_REF, structPinsData, { merge: true })
    .catch(e => console.error("Error saving struct pins:", e));
  saveState();
}

function renderStructure(){
  const f=activeFlow(), s=activeStepData();
  if(!f || !s) { $('structBody').innerHTML = '로딩 중...'; return; } // 데이터 로딩 중 처리
  
  const flowStepsSummary = f.steps.map(step => step.title).join(' - ');

  let slotsHtml = '';
  if(s.slots && Array.isArray(s.slots)){
    slotsHtml = s.slots.map((slot, index) => `
      <div class="card" data-key="${slot.key}" data-slot-name="${slot.name}" draggable="true" data-index="${index}">
        <strong>${slot.name} (${slot.key.toUpperCase().split('_')[0]})</strong>
        <div class="meta-content">${slot.content || ''}</div>
      </div>
    `).join('');
  }
  
  $('structBody').innerHTML = `
    <h2 id="stepTitle" class="editable-title">${s.title}</h2>
    <p id="stepBody" class="struct-desc editable-body">${s.body||'설명 없음'}</p>
    <div class="grid">${slotsHtml}</div>
    <div class="slot-tools">
        <button class="btn" id="btnAddSlot">슬롯 추가</button>
        <button class="btn danger" id="btnDeleteSlot">슬롯 삭제</button>
    </div>
    `;

  $('crumbs').innerText = f.title + ' › ' + flowStepsSummary; 
  $('bar').style.width = ((currentStep+1)/flowLen()*100)+'%';
  $('footer').innerText = `${f.title} · Step ${currentStep+1}/${flowLen()}`;
  $('btnPrev').disabled = currentStep===0;
  $('btnNext').disabled = currentStep===flowLen()-1;

  renderStructPinLayer();
  attachEditListeners();
}

// 편집 리스너 부착
function attachEditListeners(){
    const s = activeStepData();
    
    // 1. 단계 제목 편집
    $('stepTitle').addEventListener('dblclick', (e) => {
        const newTitle = prompt('단계 이름 변경:', s.title);
        if (newTitle !== null && newTitle.trim() !== '') {
            s.title = newTitle.trim();
            saveFlows(flows); // Firebase 저장
            renderAll();
        }
    });

    // 2. 단계 설명 편집
    $('stepBody').addEventListener('dblclick', (e) => {
        const newBody = prompt('단계 설명 변경:', s.body);
        if (newBody !== null) {
            s.body = newBody.trim() || '설명 없음';
            saveFlows(flows); // Firebase 저장
            renderStructure();
        }
    });

    // 3. 슬롯 콘텐츠 편집
    document.querySelectorAll('#structBody .card').forEach(card => {
        card.addEventListener('dblclick', (e) => {
            if(card.classList.contains('dragging')) return; 
            
            const key = card.dataset.key;
            const slot = s.slots.find(sl => sl.key === key);
            
            const newContent = prompt(`'${slot.name}' 내용 수정:`, slot.content || '');

            if (newContent !== null) {
                slot.content = newContent.trim();
                saveFlows(flows); // Firebase 저장
                renderStructure();
            }
        });
    });

    // 4. 슬롯 추가 버튼
    $('btnAddSlot').addEventListener('click', () => {
        const name = prompt('새 슬롯의 이름(제목)을 입력하세요:').trim();
        if (!name) return;
        const key = name.toLowerCase().replace(/[^a-z0-9]/g, '_').slice(0, 10) + uuid().slice(0,4);
        
        s.slots.push({ key: key, name: name, content: '' });
        saveFlows(flows); // Firebase 저장
        renderStructure();
    });

    // 5. 슬롯 삭제 버튼
    $('btnDeleteSlot').addEventListener('click', () => {
        if (!s.slots || s.slots.length === 0) { alert('삭제할 슬롯이 없습니다.'); return; }
        
        const slotNames = s.slots.map((sl, idx) => `${idx + 1}. ${sl.name}`).join('\n');
        const indexStr = prompt(`삭제할 슬롯의 번호(1~${s.slots.length})를 입력하세요:\n\n${slotNames}`);
        const index = parseInt(indexStr, 10) - 1;

        if (index >= 0 && index < s.slots.length) {
            if(confirm(`"${s.slots[index].name}" 슬롯을 삭제하시겠습니까?`)){
                s.slots.splice(index, 1);
                saveFlows(flows); // Firebase 저장
                renderStructure();
            }
        } else if(indexStr !== null && indexStr.trim() !== ''){
            alert('유효하지 않은 번호입니다.');
        }
    });

    // 6. 슬롯 드래그앤드롭 (순서 변경)
    let dragSrcEl = null;

    document.querySelectorAll('#structBody .card').forEach(card => {
        card.addEventListener('drop', (e) => {
            e.stopPropagation();
            card.classList.remove('drag-over');
            
            const fromIndex = parseInt(e.dataTransfer.getData('text/plain'), 10);
            const toIndex = parseInt(card.dataset.index, 10);

            if (fromIndex !== toIndex) {
                const [movedItem] = s.slots.splice(fromIndex, 1);
                s.slots.splice(toIndex, 0, movedItem);
                
                saveFlows(flows); // Firebase 저장
                renderStructure(); 
            }
        });
    });
}


let structPinMode=false;
$('structPinMode').addEventListener('change', e=>{ structPinMode = e.target.checked; });
$('btnStructClearPins').addEventListener('click', ()=>{ setStructPins([]); renderStructPinLayer(); });

function renderStructPinLayer(){
  const layer = $('structPinLayer'); layer.innerHTML='';
  const list = structPins();
  list.forEach((p,idx)=>{
    const pin = document.createElement('div');
    pin.className='pin'; pin.innerText=String(idx+1);
    pin.style.left=p.x+'%'; pin.style.top=p.y+'%';
    const note=document.createElement('div');
    note.className='pinNote'; note.textContent=p.text||'(메모 없음)'; note.style.display='none';
    pin.addEventListener('mouseenter', ()=>{ note.style.display='block'; });
    pin.addEventListener('mouseleave', ()=>{ note.style.display='none'; });
    pin.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      const v = prompt('핀 수정 (비우면 삭제)', p.text||'');
      if(v===null) return;
      const arr=list.slice();
      if(v.trim()===''){ setStructPins(arr.filter(x=>x.id!==p.id)); }
      else { p.text=v.trim(); setStructPins(arr); }
      renderStructPinLayer();
    });
    const wrap=document.createElement('div');
    wrap.style.position='absolute'; wrap.style.left=p.x+'%'; wrap.style.top=p.y+'%'; wrap.style.transform='translate(-50%,-50%)';
    wrap.appendChild(pin); wrap.appendChild(note);
    layer.appendChild(wrap);
  });
}
$('structPanel').addEventListener('click', (e)=>{
  if(!structPinMode) return;
  if(e.target.closest('.structTools') || e.target.closest('.card') || e.target.closest('#stepTitle') || e.target.closest('#stepBody') || e.target.closest('.slot-tools')) return; 
  
  const rect = $('structPanel').getBoundingClientRect();
  const x = ((e.clientX-rect.left)/rect.width)*100;
  const y = ((e.clientY-rect.top)/rect.height)*100;
  const text = prompt('메모 내용을 입력하세요:');
  if(text===null) return;
  const list = structPins();
  list.push({id:uuid(), x:+x.toFixed(2), y:+y.toFixed(2), text:text.trim()});
  setStructPins(list); renderStructPinLayer();
  
  // ✨ UX 개선: 핀 추가 후 모드 자동 해제
  structPinMode = false;
  $('structPinMode').checked = false;
});
/* Live: Iframe + Images */
function getSrc(){ return localStorage.getItem(STORAGE.SRC) || ''; }
function setSrc(v){
  localStorage.setItem(STORAGE.SRC, v);
  $('srcStatus').innerText='현재: '+(v||'연결되지 않음');
  if(v){ 
    $('liveFrame').src=v; 
    localStorage.setItem(STORAGE.MODE, 'iframe'); 
  }
}
$('applySrc').onclick=()=>{ const v=$('srcText').value.trim(); if(v) setSrc(v); updateLiveMode(localStorage.getItem(STORAGE.MODE)); }; 
$('srcFile').addEventListener('change', e=>{ const f=e.target.files[0]; if(!f) return; setSrc(URL.createObjectURL(f)); updateLiveMode('iframe'); }); 

function liveHashForStep(flowKey, stepIdx){
  const f=flows.find(x=>x.key===flowKey); const key=f.map[stepIdx];
  const map={ home:'#home', shop:'#shop', product:'#shop', checkout:'#shop', done:'#mypage',
              apply:'#home', klgc:'#classes', upload:'#shop', publish:'#shop',
              classes:'#classes', detail:'#classes', enroll:'#classes', play:'#classes',
              create:'#classes', sell:'#shop', legacy:'#mypage',
              community:'#community', board:'#community', credit:'#mypage', next:'#home' };
  return map[key] || '#home';
}
function navIframe(){
  const hash = liveHashForStep(activeFlow().key, currentStep);
  try{ $('liveFrame').contentWindow.location.hash=hash; }catch(e){}
}
/* 이미지 매핑 (Storage URL 사용) */
function imgForStep(flowKey, stepIdx){
  return imgSrc?.[flowKey]?.stepMap?.[stepIdx] || '';
}

// V9.0: 이미지를 Firebase Storage에 업로드하고 URL을 Firestore에 저장합니다.
async function uploadAndAssignImages(files, start){
    const flowKey = activeFlow().key;
    if(!imgSrc[flowKey]) imgSrc[flowKey] = { stepMap: {}, gallery: [] };
    const flowData = imgSrc[flowKey];

    const loadingOverlay = $('loadingOverlay');
    const progressBar = $('progressBar');
    const progressText = $('progressText');
    const loadingTitle = $('loadingTitle');
    
    loadingOverlay.style.display = 'flex';

    for(let i=0; i<files.length; i++){
        const file = files[i];
        // Storage 파일 경로: teams/knitverse/flowKey/uuid_filename
        const fileName = `${FIREBASE_DOC_PATH}/${flowKey}/${uuid()}_${file.name}`;
        const storageRef = window.ref(storage, fileName);

        loadingTitle.textContent = `이미지 업로드 중: ${i + 1}/${files.length}`;
        progressBar.style.width = '0%';
        progressText.textContent = '0%';
        
        // 1. 파일을 Base64로 읽기
        const base64 = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });

        // 2. Base64를 Storage에 업로드 (업로드 중 진행률 업데이트)
        try {
            const uploadTask = window.uploadString(storageRef, base64, 'data_url');
            
            // 업로드 진행률 추적
            await new Promise((resolve) => {
                uploadTask.on('state_changed', 
                    (snapshot) => {
                        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                        progressBar.style.width = `${progress}%`;
                        progressText.textContent = `${Math.round(progress)}%`;
                    }, 
                    (error) => {
                        console.error("Upload error:", error);
                        alert(`업로드 중 오류 발생: ${file.name}`);
                        resolve(); // 오류가 나더라도 다음 파일로 넘어가기 위해 resolve
                    }, 
                    () => {
                        resolve(); // 성공 시 resolve
                    }
                );
            });
            
            const url = await window.getDownloadURL(storageRef);
            
            // 3. Firestore 데이터 업데이트
            flowData.gallery.push(url);
            if(start + i < flowLen()){
                flowData.stepMap[start + i] = url;
            }

        } catch(e) {
            console.error(`Error processing file ${file.name}:`, e);
            alert(`이미지 처리 실패: ${file.name}`);
        }
    }

    loadingOverlay.style.display = 'none';

    // 최종적으로 모든 이미지 URL 맵을 Firestore에 저장합니다.
    window.setDoc(IMAGES_REF, imgSrc, { merge: true })
        .catch(e => console.error("Error saving image map:", e));
        
    localStorage.setItem(STORAGE.MODE, 'images');
    setSrc(''); 
    updateLiveMode('images');
    renderThumbs(); renderImages();
}

// 썸네일 리스트 렌더링
function renderThumbs(){
  const flowKey = activeFlow().key;
  if(!imgSrc[flowKey]) imgSrc[flowKey] = { stepMap: {}, gallery: [] };
  const d = imgSrc[flowKey];
  const list=$('imgList'); list.innerHTML='';
  const steps=activeFlow().steps; 
  
  for(let i=0;i<steps.length;i++){
    const url=imgForStep(flowKey, i);
    const el=document.createElement('div');
    el.className='thumb'+(i===currentStep?' active':''); el.setAttribute('draggable','true'); el.dataset.step=i;
    // V9.0: 썸네일 삭제 시 Storage에서도 이미지 파일을 삭제합니다.
    const deleteBtn = url ? `<button class="del">x</button>` : '';

    el.innerHTML = deleteBtn +
                   (url?`<img src="${url}">`:'') +
                   `<div class="cap">Step ${i+1}<br>${steps[i].title}${url?'':'<br>(비어 있음)'}</div>`;
    
    el.querySelector('.del')?.addEventListener('click', async ev=>{ 
        ev.stopPropagation(); 
        const urlToDelete = d.stepMap[i];
        if(!confirm(`이미지를 삭제하시겠습니까? Storage에서도 영구 삭제됩니다.`)) return;

        // 1. Storage에서 파일 삭제
        try {
            const fileRef = window.ref(storage, urlToDelete);
            await window.deleteObject(fileRef);
        } catch (e) {
            console.warn("Storage deletion failed (file might not exist or permission error):", e);
        }

        // 2. Firestore map 업데이트 및 저장
        delete d.stepMap[i]; 
        // 갤러리에서도 해당 URL 제거
        d.gallery = d.gallery.filter(itemUrl => itemUrl !== urlToDelete);

        await window.setDoc(IMAGES_REF, imgSrc, { merge: true });
        // 리스너가 업데이트를 처리할 것입니다. (renderThumbs 호출 필요 없음)
        saveState(); 
    }); 
    el.addEventListener('click', (e)=>{ 
      if(e.target.classList.contains('del')) return;
      currentStep = i; 
      renderAll(); 
      saveState();
    });
    // 썸네일 드래그앤드롭 이벤트 리스너 (순서 변경)
    el.addEventListener('dragstart', ev=>{ ev.dataTransfer.setData('text/plain', i.toString()); el.classList.add('dragging'); });
    el.addEventListener('dragend',   ev=>{ el.classList.remove('dragging'); });
    el.addEventListener('dragover',  ev=>{ ev.preventDefault(); el.classList.add('drag-over'); });
    el.addEventListener('dragleave', ev=>{ el.classList.remove('drag-over'); });
    el.addEventListener('drop',      ev=>{
      ev.preventDefault(); el.classList.remove('drag-over');
      const from=parseInt(ev.dataTransfer.getData('text/plain'),10), to=i;
      const a=d.stepMap[from], b=d.stepMap[to];
      if(a===undefined && b===undefined) return;
      d.stepMap[from]=b; d.stepMap[to]=a; 
      window.setDoc(IMAGES_REF, imgSrc, { merge: true });
      renderThumbs(); renderImages(); saveState(); 
    });
    list.appendChild(el);
  }
  const mappedCount = steps.filter((s, i) => d.stepMap[i]).length;
  $('imgInfo').innerText = `매핑됨: ${mappedCount}/${steps.length} 단계`;
}
$('btnPickImages').onclick=()=>$('imgFiles').click();
$('imgFiles').addEventListener('change', async e=>{
  const files=Array.from(e.target.files||[]); if(!files.length) return;
  await uploadAndAssignImages(files, currentStep);
});
$('btnAssignFromCurrent').onclick=async ()=>{
  const flowKey = activeFlow().key;
  if(!imgSrc[flowKey] || !imgSrc[flowKey].gallery || imgSrc[flowKey].gallery.length === 0){ 
      alert('먼저 이미지를 선택하세요.'); return; 
  }
  
  // 맵핑 초기화 및 새로 맵핑
  imgSrc[flowKey].stepMap={}; 
  let s=currentStep; 
  imgSrc[flowKey].gallery.forEach(u=>{ 
      if(s < flowLen()){ 
          imgSrc[flowKey].stepMap[s] = u; s++; 
      } 
  });
  
  await window.setDoc(IMAGES_REF, imgSrc, { merge: true });

  localStorage.setItem(STORAGE.MODE, 'images');
  setSrc('');
  updateLiveMode('images'); 
  renderThumbs(); renderImages();
  saveState();
};
$('btnClearMap').onclick=()=>{ 
    const flowKey = activeFlow().key;
    if(!imgSrc[flowKey]){
        alert('매핑할 데이터가 없습니다.');
        return;
    }
    if(!confirm('이 플로우의 모든 이미지 매핑을 초기화하시겠습니까? (저장소 파일은 삭제되지 않습니다)')) return;

    imgSrc[flowKey].stepMap = {}; 
    window.setDoc(IMAGES_REF, imgSrc, { merge: true });
    
    renderThumbs(); renderImages(); saveState(); 
}; 

/* 이미지 핀 (Live 이미지 창 기능) */
function getPins(flowKey=activeFlow().key, step=currentStep){
  if(!pins[flowKey]) pins[flowKey]={}; 
  if(!pins[flowKey][step]) pins[flowKey][step]=[]; 
  return pins[flowKey][step];
}
function savePins(list, flowKey=activeFlow().key, step=currentStep){
  if(!pins[flowKey]) pins[flowKey]={}; 
  pins[flowKey][step]=list;

  window.setDoc(PINS_REF, pins, { merge: true })
    .catch(e => console.error("Error saving pins:", e));
  saveState();
}
let pinMode=false;
$('pinMode').addEventListener('change', e=>{ 
    pinMode = e.target.checked; 
});
$('btnClearPins').addEventListener('click', ()=>{ savePins([]); renderPins(); });

$('imgBoard').addEventListener('click', (e)=>{
  if(!pinMode) return;
  if(!imgForStep(activeFlow().key, currentStep)){ alert('이 단계에 이미지가 없습니다.'); return; }
  const rect=$('imgBoard').getBoundingClientRect();
  const x=((e.clientX-rect.left)/rect.width)*100, y=((e.clientY-rect.top)/rect.height)*100;
  const text=prompt('핀 설명을 입력하세요:'); if(text===null) return;
  const list=getPins(); list.push({id:uuid(), x:+x.toFixed(2), y:+y.toFixed(2), text:text.trim()});
  savePins(list); renderPins();

  // ✨ UX 개선: 핀 추가 후 모드 자동 해제
  pinMode = false;
  $('pinMode').checked = false;
});

function renderPins(){
  renderPinLayer('pinLayer', getPins());
}
function renderPinLayer(layerId, list){
  const layer=$(layerId); if(!layer) return; layer.innerHTML='';
  list.forEach((p,idx)=>{
    const pin=document.createElement('div');
    pin.className='pin'; pin.innerText=String(idx+1);
    pin.style.left=p.x+'%'; pin.style.top=p.y+'%';
    const note=document.createElement('div'); note.className='pinNote'; note.textContent=p.text||'(설명 없음)'; note.style.display='none';
    pin.addEventListener('mouseenter', ()=>{ note.style.display='block'; });
    pin.addEventListener('mouseleave', ()=>{ note.style.display='none'; });
    pin.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      const v=prompt('핀 수정 (비우면 삭제)', p.text||''); if(v===null) return;
      const arr=list.slice();
      if(v.trim()===''){ savePins(arr.filter(x=>x.id!==p.id)); } else { p.text=v.trim(); savePins(arr); }
      renderPins();
    });
    const wrap=document.createElement('div'); wrap.style.position='absolute'; wrap.style.left=p.x+'%'; wrap.style.top=p.y+'%'; wrap.style.transform='translate(-50%,-50%)';
    wrap.appendChild(pin); wrap.appendChild(note); layer.appendChild(wrap);
  });
}
function renderImages(){
  const url = imgForStep(activeFlow().key, currentStep) || '';
  const img = $('stepImg'); 
  if(img) {
    img.src=url;
    img.alt = url ? activeStepData().title : "Step image (No image assigned)";
  }
  if(localStorage.getItem(STORAGE.MODE) === 'images') {
    renderPins();
  }
}
/* 이미지 캡처 기능 (기존 로직 유지) */
$('btnExportImage').addEventListener('click', ()=>{
    const target = $('mainContent');
    
    const originalText = $('btnExportImage').textContent;
    $('btnExportImage').textContent = '캡처 중...';
    $('btnExportImage').disabled = true;

    html2canvas(target, {
        allowTaint: true,
        useCORS: true,
        scrollY: -window.scrollY, 
        scale: 2 
    }).then(canvas => {
        const title = activeFlow().title.replace(/[^a-z0-9]/gi, '_');
        const stepName = activeStepData().title.replace(/[^a-z0-9]/gi, '_');
        const filename = `${title}_${stepName}_${new Date().getTime()}.png`;
        
        const link = document.createElement('a');
        link.href = canvas.toDataURL('image/png');
        link.download = filename;
        link.click();

        $('btnExportImage').textContent = originalText;
        $('btnExportImage').disabled = false;
        alert('화면 캡처(PNG)가 완료되었습니다.');
    }).catch(err => {
        console.error("캡처 실패:", err);
        $('btnExportImage').textContent = originalText;
        $('btnExportImage').disabled = false;
        alert('캡처에 실패했습니다. (콘솔 로그 확인)');
    });
});
// V9.0: JSON Export/Import 기능은 Firebase 연동으로 인해 사용하지 않으므로, 로직을 제거했습니다.

/* 기타 편집 기능 (재인덱싱 로직 등은 유지) */
// V9.0: 이미지 관련 데이터는 Firebase 리스너가 처리하므로, 로컬 스토리지 shift 로직을 제거하고 saveFlows만 호출합니다.
function shiftAfterDelete(flowKey, delIdx){
    // Firestore 리스너가 데이터 구조 변경을 감지하여 처리하도록 합니다.
    // 여기서는 flows 데이터만 변경하고 saveFlows를 호출합니다.
}
function shiftAfterInsert(flowKey, insIdx){
    // Firestore 리스너가 데이터 구조 변경을 감지하여 처리하도록 합니다.
    // 여기서는 flows 데이터만 변경하고 saveFlows를 호출합니다.
}

// 단계 데이터 복제 (이미지, 핀, 구조 핀)
function cloneStepData(flowKey, fromIdx, toIdx) {
    // 1. Image Map Clone
    if (imgSrc?.[flowKey]?.stepMap?.[fromIdx]) {
        if(!imgSrc[flowKey].stepMap) imgSrc[flowKey].stepMap = {};
        imgSrc[flowKey].stepMap[toIdx] = imgSrc[flowKey].stepMap[fromIdx];
        window.setDoc(IMAGES_REF, imgSrc, { merge: true });
    }
    // 2. Pins Clone
    if (pins?.[flowKey]?.[fromIdx]) {
        if(!pins[flowKey]) pins[flowKey] = {};
        pins[flowKey][toIdx] = JSON.parse(JSON.stringify(pins[flowKey][fromIdx]));
        window.setDoc(PINS_REF, pins, { merge: true });
    }
    // 3. Structure Pins Clone
    if (structPinsData?.[flowKey]?.[fromIdx]) {
        if(!structPinsData[flowKey]) structPinsData[flowKey] = {};
        structPinsData[flowKey][toIdx] = JSON.parse(JSON.stringify(structPinsData[flowKey][fromIdx]));
        window.setDoc(SPINS_REF, structPinsData, { merge: true });
    }
}


/* 소스 전환 (모드 충돌 방지 및 단일화) */
function updateLiveMode(mode){
    const flowKey = activeFlow()?.key;
    const isImageModePreferred = (flowKey && Object.keys(imgSrc[flowKey]?.stepMap || {}).length > 0) || (localStorage.getItem(STORAGE.MODE) === 'images');
    const isIframeSourceLoaded = getSrc() && localStorage.getItem(STORAGE.MODE) === 'iframe';

    if (isImageModePreferred && !isIframeSourceLoaded) {
        localStorage.setItem(STORAGE.MODE, 'images');
        $('iframePane').style.display = 'none';
        $('imagesPane').style.display = 'block';
        renderImages(); 
    } else if (isIframeSourceLoaded) {
        localStorage.setItem(STORAGE.MODE, 'iframe');
        $('iframePane').style.display = 'block';
        $('imagesPane').style.display = 'none';
        navIframe();
    } else {
        localStorage.setItem(STORAGE.MODE, 'images');
        $('iframePane').style.display = 'none';
        $('imagesPane').style.display = 'block';
        renderImages();
    }
}

/* Flow 리스트 + DnD */
function buildFlowList(){
  const list=$('flowList'); list.innerHTML='';
  flows.forEach((f,idx)=>{
    const el=document.createElement('div');
    el.className='flow'+(idx===currentFlowIdx?' active':''); el.draggable=true; el.dataset.idx=idx;
    el.innerHTML=`<div><strong>${f.title}</strong></div><div class="meta">${f.steps.length} 단계</div><div class="reord">↕</div>`;
    el.addEventListener('click', (e)=>{ if(e.target.classList.contains('reord')) return; selectFlow(idx); });
    el.addEventListener('dragstart', ev=>{ ev.dataTransfer.setData('text/plain', idx.toString()); el.classList.add('dragging'); });
    el.addEventListener('dragend',   ev=>{ el.classList.remove('dragging'); });
    el.addEventListener('dragover',  ev=>{ ev.preventDefault(); el.classList.add('drag-over'); });
    el.addEventListener('dragleave', ev=>{ el.classList.remove('drag-over'); });
    el.addEventListener('drop',      ev=>{
      ev.preventDefault(); el.classList.remove('drag-over');
      const from=parseInt(ev.dataTransfer.getData('text/plain'),10), to=idx;
      if(from===to) return;
      const item=flows.splice(from,1)[0]; flows.splice(to,0,item);
      
      if(currentFlowIdx === from) currentFlowIdx = to;
      else if(currentFlowIdx > from && currentFlowIdx <= to) currentFlowIdx--;
      else if(currentFlowIdx < from && currentFlowIdx >= to) currentFlowIdx++;
      
      saveFlows(flows); // Firebase 저장
      buildFlowList();
      renderAll();
      saveState();
    });
    list.appendChild(el);
  });
}
function selectFlow(idx){
  currentFlowIdx = idx; currentStep=0;
  document.querySelectorAll('.flow').forEach((x,i)=>x.classList.toggle('active', i===idx));
  renderAll();
  updateLiveMode(localStorage.getItem(STORAGE.MODE) || 'images');
  saveState();
}

/* 플로우 편집: 추가/이름변경/삭제 */
const DEFAULT_STEP_COUNT = 5; 

$('btnAddFlow').addEventListener('click', ()=>{
    const title = (prompt(`새로운 플로우 이름? (기본 ${DEFAULT_STEP_COUNT}단계 생성)`)||'').trim();
    if(!title) return;
    
    const defaultSteps = [];
    const defaultMap = [];
    for(let i=1; i<=DEFAULT_STEP_COUNT; i++){
        defaultSteps.push({
            title: `Step ${i}`,
            body: `새로 추가된 플로우의 ${i}번째 단계입니다.`,
            slots: [
                {key:'core', name:'핵심 요소', content: '핵심 요소'},
                {key:'link', name:'연결', content: '다음 화면으로 넘어가는 트리거'},
                {key:'metric', name:'메트릭', content: '전환/이탈 포인트, GA 이벤트'}
            ]
        });
        defaultMap.push('home'); 
    }

    const newFlow = {
        key: uuid(),
        title: title,
        map: defaultMap,
        steps: defaultSteps
    };
    
    flows.push(newFlow);
    saveFlows(flows); // Firebase 저장
    currentFlowIdx = flows.length - 1;
    currentStep = 0;
    buildFlowList();
    renderAll();
    saveState();
});

$('btnRenameFlow').addEventListener('click', ()=>{
    const f = activeFlow();
    const next = (prompt('플로우 이름 변경:', f.title)||'').trim();
    if(!next) return;
    f.title = next;
    saveFlows(flows); // Firebase 저장
    buildFlowList();
    renderAll();
    saveState();
});

$('btnDeleteFlow').addEventListener('click', ()=>{
    if(flows.length <= 1){ alert('최소 1개의 플로우는 필요합니다.'); return; }
    const f = activeFlow();
    if(!confirm(`플로우 "${f.title}" (총 ${f.steps.length} 단계)를 정말로 삭제할까요? 이 플로우의 모든 이미지와 데이터가 영구 삭제됩니다.`)) return;
    
    const flowKeyToDelete = f.key;
    const updateFirebaseDoc = async (docRef, data, flowKey) => {
        if(data[flowKey]) {
            delete data[flowKey];
            await window.setDoc(docRef, data);
        }
    }
    
    // 이미지 파일 삭제는 복잡하므로 현재는 Firestore 데이터만 삭제합니다.
    // *주의: Storage에 저장된 이미지 파일 자체는 수동으로 삭제해야 합니다.*
    
    // Firestore 데이터 삭제 (pins, structPins, imgSrc)
    updateFirebaseDoc(PINS_REF, pins, flowKeyToDelete);
    updateFirebaseDoc(SPINS_REF, structPinsData, flowKeyToDelete);
    updateFirebaseDoc(IMAGES_REF, imgSrc, flowKeyToDelete);
    

    flows.splice(currentFlowIdx, 1);
    if(currentFlowIdx >= flows.length) currentFlowIdx = flows.length - 1;
    currentStep = 0; 
    
    saveFlows(flows); // Firebase 저장
    buildFlowList();
    renderAll();
    saveState();
});


/* 네비게이션 버튼 (이전/다음 클릭 시 renderAll 호출) */
$('btnPrev').addEventListener('click', ()=>{ if(currentStep>0){ currentStep--; renderAll(); saveState(); } });
$('btnNext').addEventListener('click', ()=>{ if(currentStep<flowLen()-1){ currentStep++; renderAll(); saveState(); } });
function renderAll(){
  renderStructure();
  renderThumbs(); 
  updateLiveMode(localStorage.getItem(STORAGE.MODE));
}
/* 단계 편집: 추가/복제/이름변경/삭제 */
function addNewStep(){
    const f = activeFlow();
    const title = (prompt('새 단계 이름?', 'New Step')||'').trim();
    if(!title) return;
    const body  = (prompt('설명(선택):', '')||'').trim();
    const insertAt = currentStep+1;
    shiftAfterInsert(f.key, insertAt);
    f.steps.splice(insertAt, 0, { 
        title, 
        body: body||'설명 없음', 
        slots: [
            {key:'core', name:'핵심 요소', content: '핵심 요소'},
            {key:'link', name:'연결', content: '다음 화면으로 넘어가는 트리거'},
            {key:'metric', name:'메트릭', content: '전환/이탈 포인트, GA 이벤트'}
        ]
    });
    f.map.splice(insertAt, 0, f.map[currentStep] || 'home');
    saveFlows(flows); // Firebase 저장
    currentStep = insertAt;
    renderAll(); navIframe(); saveState();
}

function cloneStep() {
    const f = activeFlow();
    const s = activeStepData();
    
    const cloneTitle = (prompt('복제할 단계 이름?', s.title + ' (복제)')||'').trim();
    if(!cloneTitle) return;

    const currentIdx = currentStep;
    const insertAt = currentStep + 1;
    
    shiftAfterInsert(f.key, insertAt);

    const newStep = JSON.parse(JSON.stringify(s));
    newStep.title = cloneTitle;

    f.steps.splice(insertAt, 0, newStep);
    f.map.splice(insertAt, 0, f.map[currentIdx] || 'home'); 
    saveFlows(flows); // Firebase 저장

    cloneStepData(f.key, currentIdx, insertAt);

    currentStep = insertAt;
    renderAll(); navIframe(); saveState();
}


function renameStep(){
    const f = activeFlow();
    const s = f.steps[currentStep];
    const next = (prompt('단계 이름 변경:', s.title)||'').trim();
    if(!next) return;
    s.title = next;
    saveFlows(flows); // Firebase 저장
    renderAll(); saveState();
}
function deleteStep(){
    const f = activeFlow();
    if(f.steps.length<=1){ alert('최소 1단계는 필요합니다.'); return; }
    if(!confirm(`현재 단계 "${f.steps[currentStep].title}" 를 삭제할까요?`)) return;
    const delIdx = currentStep;
    shiftAfterDelete(f.key, delIdx);
    f.steps.splice(delIdx,1);
    f.map.splice(delIdx,1);
    if(currentStep>=f.steps.length) currentStep=f.steps.length-1;
    saveFlows(flows); // Firebase 저장
    renderAll(); navIframe(); saveState();
}

$('btnStepAdd').addEventListener('click', addNewStep);
$('btnStepClone').addEventListener('click', cloneStep); 
$('btnStepRename').addEventListener('click', renameStep);
$('btnStepDelete').addEventListener('click', deleteStep);


/* 초기 시작 */
(function init(){
  initFlows();
  buildFlowList();
  
  const src = getSrc(); 
  if(!localStorage.getItem(STORAGE.MODE)){
      if(src) {
          localStorage.setItem(STORAGE.MODE, 'iframe');
      } else {
          localStorage.setItem(STORAGE.MODE, 'images');
      }
  }
  
  // loadState()는 Firestore 리스너가 처리하므로 삭제
  if(currentFlowIdx >= flows.length) currentFlowIdx = 0;
  if(currentStep >= flowLen()) currentStep = flowLen() - 1;
  
  selectFlow(currentFlowIdx); 
})();
</script>
</body>
</html>
